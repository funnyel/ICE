<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>formats.pngdecoder</title>
  <style type="text/css">
  .linescolumn > a { display: block; }
  td { vertical-align: top; }
  </style>
  <link href="html.css" rel="stylesheet" type="text/css">
</head>
<body>
<table><tr><td class="linescolumn"><a id="L1" href="#L1">1</a><a id="L2" href="#L2">2</a><a id="L3" href="#L3">3</a><a id="L4" href="#L4">4</a><a id="L5" href="#L5">5</a><a id="L6" href="#L6">6</a><a id="L7" href="#L7">7</a><a id="L8" href="#L8">8</a><a id="L9" href="#L9">9</a><a id="L10" href="#L10">10</a><a id="L11" href="#L11">11</a><a id="L12" href="#L12">12</a><a id="L13" href="#L13">13</a><a id="L14" href="#L14">14</a><a id="L15" href="#L15">15</a><a id="L16" href="#L16">16</a><a id="L17" href="#L17">17</a><a id="L18" href="#L18">18</a><a id="L19" href="#L19">19</a><a id="L20" href="#L20">20</a><a id="L21" href="#L21">21</a><a id="L22" href="#L22">22</a><a id="L23" href="#L23">23</a><a id="L24" href="#L24">24</a><a id="L25" href="#L25">25</a><a id="L26" href="#L26">26</a><a id="L27" href="#L27">27</a><a id="L28" href="#L28">28</a><a id="L29" href="#L29">29</a><a id="L30" href="#L30">30</a><a id="L31" href="#L31">31</a><a id="L32" href="#L32">32</a><a id="L33" href="#L33">33</a><a id="L34" href="#L34">34</a><a id="L35" href="#L35">35</a><a id="L36" href="#L36">36</a><a id="L37" href="#L37">37</a><a id="L38" href="#L38">38</a><a id="L39" href="#L39">39</a><a id="L40" href="#L40">40</a><a id="L41" href="#L41">41</a><a id="L42" href="#L42">42</a><a id="L43" href="#L43">43</a><a id="L44" href="#L44">44</a><a id="L45" href="#L45">45</a><a id="L46" href="#L46">46</a><a id="L47" href="#L47">47</a><a id="L48" href="#L48">48</a><a id="L49" href="#L49">49</a><a id="L50" href="#L50">50</a><a id="L51" href="#L51">51</a><a id="L52" href="#L52">52</a><a id="L53" href="#L53">53</a><a id="L54" href="#L54">54</a><a id="L55" href="#L55">55</a><a id="L56" href="#L56">56</a><a id="L57" href="#L57">57</a><a id="L58" href="#L58">58</a><a id="L59" href="#L59">59</a><a id="L60" href="#L60">60</a><a id="L61" href="#L61">61</a><a id="L62" href="#L62">62</a><a id="L63" href="#L63">63</a><a id="L64" href="#L64">64</a><a id="L65" href="#L65">65</a><a id="L66" href="#L66">66</a><a id="L67" href="#L67">67</a><a id="L68" href="#L68">68</a><a id="L69" href="#L69">69</a><a id="L70" href="#L70">70</a><a id="L71" href="#L71">71</a><a id="L72" href="#L72">72</a><a id="L73" href="#L73">73</a><a id="L74" href="#L74">74</a><a id="L75" href="#L75">75</a><a id="L76" href="#L76">76</a><a id="L77" href="#L77">77</a><a id="L78" href="#L78">78</a><a id="L79" href="#L79">79</a><a id="L80" href="#L80">80</a><a id="L81" href="#L81">81</a><a id="L82" href="#L82">82</a><a id="L83" href="#L83">83</a><a id="L84" href="#L84">84</a><a id="L85" href="#L85">85</a><a id="L86" href="#L86">86</a><a id="L87" href="#L87">87</a><a id="L88" href="#L88">88</a><a id="L89" href="#L89">89</a><a id="L90" href="#L90">90</a><a id="L91" href="#L91">91</a><a id="L92" href="#L92">92</a><a id="L93" href="#L93">93</a><a id="L94" href="#L94">94</a><a id="L95" href="#L95">95</a><a id="L96" href="#L96">96</a><a id="L97" href="#L97">97</a><a id="L98" href="#L98">98</a><a id="L99" href="#L99">99</a><a id="L100" href="#L100">100</a><a id="L101" href="#L101">101</a><a id="L102" href="#L102">102</a><a id="L103" href="#L103">103</a><a id="L104" href="#L104">104</a><a id="L105" href="#L105">105</a><a id="L106" href="#L106">106</a><a id="L107" href="#L107">107</a><a id="L108" href="#L108">108</a><a id="L109" href="#L109">109</a><a id="L110" href="#L110">110</a><a id="L111" href="#L111">111</a><a id="L112" href="#L112">112</a><a id="L113" href="#L113">113</a><a id="L114" href="#L114">114</a><a id="L115" href="#L115">115</a><a id="L116" href="#L116">116</a><a id="L117" href="#L117">117</a><a id="L118" href="#L118">118</a><a id="L119" href="#L119">119</a><a id="L120" href="#L120">120</a><a id="L121" href="#L121">121</a><a id="L122" href="#L122">122</a><a id="L123" href="#L123">123</a><a id="L124" href="#L124">124</a><a id="L125" href="#L125">125</a><a id="L126" href="#L126">126</a><a id="L127" href="#L127">127</a><a id="L128" href="#L128">128</a><a id="L129" href="#L129">129</a><a id="L130" href="#L130">130</a><a id="L131" href="#L131">131</a><a id="L132" href="#L132">132</a><a id="L133" href="#L133">133</a><a id="L134" href="#L134">134</a><a id="L135" href="#L135">135</a><a id="L136" href="#L136">136</a><a id="L137" href="#L137">137</a><a id="L138" href="#L138">138</a><a id="L139" href="#L139">139</a><a id="L140" href="#L140">140</a><a id="L141" href="#L141">141</a><a id="L142" href="#L142">142</a><a id="L143" href="#L143">143</a><a id="L144" href="#L144">144</a><a id="L145" href="#L145">145</a><a id="L146" href="#L146">146</a><a id="L147" href="#L147">147</a><a id="L148" href="#L148">148</a><a id="L149" href="#L149">149</a><a id="L150" href="#L150">150</a><a id="L151" href="#L151">151</a><a id="L152" href="#L152">152</a><a id="L153" href="#L153">153</a><a id="L154" href="#L154">154</a><a id="L155" href="#L155">155</a><a id="L156" href="#L156">156</a><a id="L157" href="#L157">157</a><a id="L158" href="#L158">158</a><a id="L159" href="#L159">159</a><a id="L160" href="#L160">160</a><a id="L161" href="#L161">161</a><a id="L162" href="#L162">162</a><a id="L163" href="#L163">163</a><a id="L164" href="#L164">164</a><a id="L165" href="#L165">165</a><a id="L166" href="#L166">166</a><a id="L167" href="#L167">167</a><a id="L168" href="#L168">168</a><a id="L169" href="#L169">169</a><a id="L170" href="#L170">170</a><a id="L171" href="#L171">171</a><a id="L172" href="#L172">172</a><a id="L173" href="#L173">173</a><a id="L174" href="#L174">174</a><a id="L175" href="#L175">175</a><a id="L176" href="#L176">176</a><a id="L177" href="#L177">177</a><a id="L178" href="#L178">178</a><a id="L179" href="#L179">179</a><a id="L180" href="#L180">180</a><a id="L181" href="#L181">181</a><a id="L182" href="#L182">182</a><a id="L183" href="#L183">183</a><a id="L184" href="#L184">184</a><a id="L185" href="#L185">185</a><a id="L186" href="#L186">186</a><a id="L187" href="#L187">187</a><a id="L188" href="#L188">188</a><a id="L189" href="#L189">189</a><a id="L190" href="#L190">190</a><a id="L191" href="#L191">191</a><a id="L192" href="#L192">192</a><a id="L193" href="#L193">193</a><a id="L194" href="#L194">194</a><a id="L195" href="#L195">195</a><a id="L196" href="#L196">196</a><a id="L197" href="#L197">197</a><a id="L198" href="#L198">198</a><a id="L199" href="#L199">199</a><a id="L200" href="#L200">200</a><a id="L201" href="#L201">201</a><a id="L202" href="#L202">202</a><a id="L203" href="#L203">203</a><a id="L204" href="#L204">204</a><a id="L205" href="#L205">205</a><a id="L206" href="#L206">206</a><a id="L207" href="#L207">207</a><a id="L208" href="#L208">208</a><a id="L209" href="#L209">209</a><a id="L210" href="#L210">210</a><a id="L211" href="#L211">211</a><a id="L212" href="#L212">212</a><a id="L213" href="#L213">213</a><a id="L214" href="#L214">214</a><a id="L215" href="#L215">215</a><a id="L216" href="#L216">216</a><a id="L217" href="#L217">217</a><a id="L218" href="#L218">218</a><a id="L219" href="#L219">219</a><a id="L220" href="#L220">220</a><a id="L221" href="#L221">221</a><a id="L222" href="#L222">222</a><a id="L223" href="#L223">223</a><a id="L224" href="#L224">224</a><a id="L225" href="#L225">225</a><a id="L226" href="#L226">226</a><a id="L227" href="#L227">227</a><a id="L228" href="#L228">228</a><a id="L229" href="#L229">229</a><a id="L230" href="#L230">230</a><a id="L231" href="#L231">231</a><a id="L232" href="#L232">232</a><a id="L233" href="#L233">233</a><a id="L234" href="#L234">234</a><a id="L235" href="#L235">235</a><a id="L236" href="#L236">236</a><a id="L237" href="#L237">237</a><a id="L238" href="#L238">238</a><a id="L239" href="#L239">239</a><a id="L240" href="#L240">240</a><a id="L241" href="#L241">241</a><a id="L242" href="#L242">242</a><a id="L243" href="#L243">243</a><a id="L244" href="#L244">244</a><a id="L245" href="#L245">245</a><a id="L246" href="#L246">246</a><a id="L247" href="#L247">247</a><a id="L248" href="#L248">248</a><a id="L249" href="#L249">249</a><a id="L250" href="#L250">250</a><a id="L251" href="#L251">251</a><a id="L252" href="#L252">252</a><a id="L253" href="#L253">253</a><a id="L254" href="#L254">254</a><a id="L255" href="#L255">255</a><a id="L256" href="#L256">256</a><a id="L257" href="#L257">257</a><a id="L258" href="#L258">258</a><a id="L259" href="#L259">259</a><a id="L260" href="#L260">260</a><a id="L261" href="#L261">261</a><a id="L262" href="#L262">262</a><a id="L263" href="#L263">263</a><a id="L264" href="#L264">264</a><a id="L265" href="#L265">265</a><a id="L266" href="#L266">266</a><a id="L267" href="#L267">267</a><a id="L268" href="#L268">268</a><a id="L269" href="#L269">269</a><a id="L270" href="#L270">270</a><a id="L271" href="#L271">271</a><a id="L272" href="#L272">272</a><a id="L273" href="#L273">273</a><a id="L274" href="#L274">274</a><a id="L275" href="#L275">275</a><a id="L276" href="#L276">276</a><a id="L277" href="#L277">277</a><a id="L278" href="#L278">278</a><a id="L279" href="#L279">279</a><a id="L280" href="#L280">280</a><a id="L281" href="#L281">281</a><a id="L282" href="#L282">282</a><a id="L283" href="#L283">283</a><a id="L284" href="#L284">284</a><a id="L285" href="#L285">285</a><a id="L286" href="#L286">286</a><a id="L287" href="#L287">287</a><a id="L288" href="#L288">288</a><a id="L289" href="#L289">289</a><a id="L290" href="#L290">290</a><a id="L291" href="#L291">291</a><a id="L292" href="#L292">292</a><a id="L293" href="#L293">293</a><a id="L294" href="#L294">294</a><a id="L295" href="#L295">295</a><a id="L296" href="#L296">296</a><a id="L297" href="#L297">297</a><a id="L298" href="#L298">298</a><a id="L299" href="#L299">299</a><a id="L300" href="#L300">300</a><a id="L301" href="#L301">301</a><a id="L302" href="#L302">302</a><a id="L303" href="#L303">303</a><a id="L304" href="#L304">304</a><a id="L305" href="#L305">305</a><a id="L306" href="#L306">306</a><a id="L307" href="#L307">307</a><a id="L308" href="#L308">308</a><a id="L309" href="#L309">309</a><a id="L310" href="#L310">310</a><a id="L311" href="#L311">311</a><a id="L312" href="#L312">312</a><a id="L313" href="#L313">313</a><a id="L314" href="#L314">314</a><a id="L315" href="#L315">315</a><a id="L316" href="#L316">316</a><a id="L317" href="#L317">317</a><a id="L318" href="#L318">318</a><a id="L319" href="#L319">319</a><a id="L320" href="#L320">320</a><a id="L321" href="#L321">321</a><a id="L322" href="#L322">322</a><a id="L323" href="#L323">323</a><a id="L324" href="#L324">324</a><a id="L325" href="#L325">325</a><a id="L326" href="#L326">326</a><a id="L327" href="#L327">327</a><a id="L328" href="#L328">328</a><a id="L329" href="#L329">329</a><a id="L330" href="#L330">330</a><a id="L331" href="#L331">331</a><a id="L332" href="#L332">332</a><a id="L333" href="#L333">333</a><a id="L334" href="#L334">334</a><a id="L335" href="#L335">335</a><a id="L336" href="#L336">336</a><a id="L337" href="#L337">337</a><a id="L338" href="#L338">338</a><a id="L339" href="#L339">339</a><a id="L340" href="#L340">340</a><a id="L341" href="#L341">341</a><a id="L342" href="#L342">342</a><a id="L343" href="#L343">343</a><a id="L344" href="#L344">344</a><a id="L345" href="#L345">345</a><a id="L346" href="#L346">346</a><a id="L347" href="#L347">347</a><a id="L348" href="#L348">348</a><a id="L349" href="#L349">349</a><a id="L350" href="#L350">350</a><a id="L351" href="#L351">351</a><a id="L352" href="#L352">352</a><a id="L353" href="#L353">353</a><a id="L354" href="#L354">354</a><a id="L355" href="#L355">355</a><a id="L356" href="#L356">356</a><a id="L357" href="#L357">357</a><a id="L358" href="#L358">358</a><a id="L359" href="#L359">359</a><a id="L360" href="#L360">360</a><a id="L361" href="#L361">361</a><a id="L362" href="#L362">362</a><a id="L363" href="#L363">363</a><a id="L364" href="#L364">364</a><a id="L365" href="#L365">365</a><a id="L366" href="#L366">366</a><a id="L367" href="#L367">367</a><a id="L368" href="#L368">368</a><a id="L369" href="#L369">369</a><a id="L370" href="#L370">370</a><a id="L371" href="#L371">371</a><a id="L372" href="#L372">372</a><a id="L373" href="#L373">373</a><a id="L374" href="#L374">374</a><a id="L375" href="#L375">375</a><a id="L376" href="#L376">376</a><a id="L377" href="#L377">377</a><a id="L378" href="#L378">378</a><a id="L379" href="#L379">379</a><a id="L380" href="#L380">380</a><a id="L381" href="#L381">381</a><a id="L382" href="#L382">382</a><a id="L383" href="#L383">383</a><a id="L384" href="#L384">384</a><a id="L385" href="#L385">385</a><a id="L386" href="#L386">386</a><a id="L387" href="#L387">387</a><a id="L388" href="#L388">388</a><a id="L389" href="#L389">389</a><a id="L390" href="#L390">390</a><a id="L391" href="#L391">391</a><a id="L392" href="#L392">392</a><a id="L393" href="#L393">393</a><a id="L394" href="#L394">394</a><a id="L395" href="#L395">395</a><a id="L396" href="#L396">396</a><a id="L397" href="#L397">397</a><a id="L398" href="#L398">398</a><a id="L399" href="#L399">399</a><a id="L400" href="#L400">400</a><a id="L401" href="#L401">401</a><a id="L402" href="#L402">402</a><a id="L403" href="#L403">403</a><a id="L404" href="#L404">404</a><a id="L405" href="#L405">405</a><a id="L406" href="#L406">406</a><a id="L407" href="#L407">407</a><a id="L408" href="#L408">408</a><a id="L409" href="#L409">409</a><a id="L410" href="#L410">410</a><a id="L411" href="#L411">411</a><a id="L412" href="#L412">412</a><a id="L413" href="#L413">413</a><a id="L414" href="#L414">414</a><a id="L415" href="#L415">415</a><a id="L416" href="#L416">416</a><a id="L417" href="#L417">417</a><a id="L418" href="#L418">418</a><a id="L419" href="#L419">419</a><a id="L420" href="#L420">420</a><a id="L421" href="#L421">421</a><a id="L422" href="#L422">422</a><a id="L423" href="#L423">423</a><a id="L424" href="#L424">424</a><a id="L425" href="#L425">425</a><a id="L426" href="#L426">426</a><a id="L427" href="#L427">427</a><a id="L428" href="#L428">428</a><a id="L429" href="#L429">429</a><a id="L430" href="#L430">430</a><a id="L431" href="#L431">431</a><a id="L432" href="#L432">432</a><a id="L433" href="#L433">433</a><a id="L434" href="#L434">434</a><a id="L435" href="#L435">435</a><a id="L436" href="#L436">436</a><a id="L437" href="#L437">437</a><a id="L438" href="#L438">438</a><a id="L439" href="#L439">439</a><a id="L440" href="#L440">440</a><a id="L441" href="#L441">441</a><a id="L442" href="#L442">442</a><a id="L443" href="#L443">443</a><a id="L444" href="#L444">444</a><a id="L445" href="#L445">445</a><a id="L446" href="#L446">446</a><a id="L447" href="#L447">447</a><a id="L448" href="#L448">448</a><a id="L449" href="#L449">449</a><a id="L450" href="#L450">450</a><a id="L451" href="#L451">451</a><a id="L452" href="#L452">452</a><a id="L453" href="#L453">453</a><a id="L454" href="#L454">454</a><a id="L455" href="#L455">455</a><a id="L456" href="#L456">456</a><a id="L457" href="#L457">457</a><a id="L458" href="#L458">458</a><a id="L459" href="#L459">459</a><a id="L460" href="#L460">460</a><a id="L461" href="#L461">461</a><a id="L462" href="#L462">462</a><a id="L463" href="#L463">463</a><a id="L464" href="#L464">464</a><a id="L465" href="#L465">465</a><a id="L466" href="#L466">466</a><a id="L467" href="#L467">467</a><a id="L468" href="#L468">468</a><a id="L469" href="#L469">469</a><a id="L470" href="#L470">470</a><a id="L471" href="#L471">471</a><a id="L472" href="#L472">472</a><a id="L473" href="#L473">473</a><a id="L474" href="#L474">474</a><a id="L475" href="#L475">475</a><a id="L476" href="#L476">476</a><a id="L477" href="#L477">477</a><a id="L478" href="#L478">478</a><a id="L479" href="#L479">479</a><a id="L480" href="#L480">480</a><a id="L481" href="#L481">481</a><a id="L482" href="#L482">482</a><a id="L483" href="#L483">483</a><a id="L484" href="#L484">484</a><a id="L485" href="#L485">485</a><a id="L486" href="#L486">486</a><a id="L487" href="#L487">487</a><a id="L488" href="#L488">488</a><a id="L489" href="#L489">489</a><a id="L490" href="#L490">490</a><a id="L491" href="#L491">491</a><a id="L492" href="#L492">492</a><a id="L493" href="#L493">493</a><a id="L494" href="#L494">494</a><a id="L495" href="#L495">495</a><a id="L496" href="#L496">496</a><a id="L497" href="#L497">497</a><a id="L498" href="#L498">498</a><a id="L499" href="#L499">499</a><a id="L500" href="#L500">500</a><a id="L501" href="#L501">501</a><a id="L502" href="#L502">502</a><a id="L503" href="#L503">503</a><a id="L504" href="#L504">504</a><a id="L505" href="#L505">505</a><a id="L506" href="#L506">506</a><a id="L507" href="#L507">507</a><a id="L508" href="#L508">508</a><a id="L509" href="#L509">509</a><a id="L510" href="#L510">510</a><a id="L511" href="#L511">511</a><a id="L512" href="#L512">512</a><a id="L513" href="#L513">513</a><a id="L514" href="#L514">514</a><a id="L515" href="#L515">515</a><a id="L516" href="#L516">516</a><a id="L517" href="#L517">517</a><a id="L518" href="#L518">518</a><a id="L519" href="#L519">519</a><a id="L520" href="#L520">520</a><a id="L521" href="#L521">521</a><a id="L522" href="#L522">522</a><a id="L523" href="#L523">523</a><a id="L524" href="#L524">524</a><a id="L525" href="#L525">525</a><a id="L526" href="#L526">526</a><a id="L527" href="#L527">527</a><a id="L528" href="#L528">528</a><a id="L529" href="#L529">529</a><a id="L530" href="#L530">530</a><a id="L531" href="#L531">531</a><a id="L532" href="#L532">532</a><a id="L533" href="#L533">533</a><a id="L534" href="#L534">534</a><a id="L535" href="#L535">535</a><a id="L536" href="#L536">536</a><a id="L537" href="#L537">537</a><a id="L538" href="#L538">538</a><a id="L539" href="#L539">539</a><a id="L540" href="#L540">540</a><a id="L541" href="#L541">541</a><a id="L542" href="#L542">542</a><a id="L543" href="#L543">543</a><a id="L544" href="#L544">544</a><a id="L545" href="#L545">545</a><a id="L546" href="#L546">546</a><a id="L547" href="#L547">547</a><a id="L548" href="#L548">548</a><a id="L549" href="#L549">549</a><a id="L550" href="#L550">550</a><a id="L551" href="#L551">551</a><a id="L552" href="#L552">552</a><a id="L553" href="#L553">553</a></td>
<td><td><pre class="sourcecode">
<span class="bc">/***************************************************************************************************
License:
Copyright (c) 2005-2007 Lode Vandevenne
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

  - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.&lt;br&gt;
  - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.&lt;br&gt;
  - Neither the name of Lode Vandevenne nor the names of his contributors may be used to endorse or promote products derived from this software without specific prior written permission.&lt;br&gt;

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Authors: Lode Vandevenne (original version in C++), Lutger Blijdestijn (D version) : lutger dot blijdestijn at gmail dot com, Ferdinand Majerech (Refactoring)
*/</span>

<span class="d Compound"><span class="d Module"><span class="k">module</span> <span class="i">formats</span>.<span class="i">pngdecoder</span>;</span>


<span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">string</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">intrinsic</span>;</span>

<span class="d Import"><span class="k">import</span> <span class="i">formats</span>.<span class="i">pngcommon</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">formats</span>.<span class="i">zlib</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">math</span>.<span class="i">vector2</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">memory</span>.<span class="i">memory</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">containers</span>.<span class="i">vector</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">util</span>.<span class="i">iterator</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">util</span>.<span class="i">exception</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">util</span>.<span class="i">swap</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">color</span>;</span>


<span class="d Protection"><span class="k">package</span></span>:
<span class="bc">/**
 * PNG file decoder. Supports all color types, interlacing, color key, background color, 
 * text. However, color types with less than 8 bytes per pixels are not tested at the 
 * moment and might not work.
 */</span>
<span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">PNGDecoder</span>
<span class="d Compound">{
    <span class="d Protection"><span class="k">private</span></span>:
    <span class="d Compound"><span class="d Protection"><span class="k">public</span></span>:
        <span class="bc">/**
         * Decode PNG file data.
         *
         * Params:  source = PNG data to decode.
         *          info   = PNG info object to write image information to.
         *
         * Returns: Manually allocated decoded image data. Must be freed manually.
         *
         * Throws:  PNGException on decoding error.
         *          CompressionException on PNG data decompression error.
         */</span>
        <span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">decode</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">PNGInfo</span></span> <span class="i">info</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span> <span class="i">interlace</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">PNGInfo</span></span>(<span class="i">read_header</span>(<span class="i">source</span>, <span class="i">interlace</span>))</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">interlace</span></span> = <span class="e Identifier"><span class="i">interlace</span></span></span>;</span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">expected_length</span> = <span class="e Cond"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">interlace</span></span> 
                                   ? <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">buffer_size</span></span>(<span class="i">info</span>.<span class="i">image</span>)</span> + <span class="e Mul"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">height</span></span> * <span class="e Int"><span class="n">2</span></span></span></span>
                                   : <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">buffer_size</span></span>(<span class="i">info</span>.<span class="i">image</span>)</span> + <span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">height</span></span></span></span>;</span></span>


            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">buffer</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">Vector</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>()</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">buffer</span></span>.<span class="t Identifier"><span class="i">reserve</span></span>(<span class="i">expected_length</span>);</span></span>
            <span class="s ScopeGuard"><span class="k">scope</span>(<span class="i">exit</span>)<span class="s Scope"><span class="s Compound">{<span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">buffer</span></span>.<span class="e Identifier"><span class="i">die</span></span>()</span>;</span>}</span></span></span>

            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">inflator</span> = <span class="e Call"><span class="e Identifier"><span class="i">Inflator</span></span>(<span class="i">buffer</span>)</span>;</span></span>

            <span class="s Foreach"><span class="k">foreach</span>(<span class="o Parameters"><span class="o Parameter"><span class="i">chunk</span></span></span>; <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">PNGChunkIterator</span></span>(<span class="e Slice"><span class="e Identifier"><span class="i">source</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">header_size</span></span> - <span class="e Int"><span class="n">1</span></span></span> .. <span class="e Dollar">$</span>]</span>)</span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Switch"><span class="k">switch</span>(<span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">type</span></span>)
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">//image data</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">IDAT</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">inflator</span></span>.<span class="e Identifier"><span class="i">inflate</span></span>(<span class="i">chunk</span>.<span class="i">data</span>)</span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    <span class="lc">//palette</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">PLTE</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">chunk</span>.<span class="i">data</span>.<span class="i">length</span> &lt;= <span class="n">256</span> * <span class="n">3</span>, 
                                                 <span class="sl">"Palette with over 256 colors"</span>)</span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">palette</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Div"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">length</span></span> / <span class="e Int"><span class="n">3</span></span></span></span>;</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">byte_idx</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
                        <span class="s Foreach"><span class="k">foreach</span>(<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">color</span></span></span>; <span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">palette</span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">color</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Color</span></span>(<span class="i">chunk</span>.<span class="i">data</span>[<span class="i">byte_idx</span>++],
                                          <span class="i">chunk</span>.<span class="i">data</span>[<span class="i">byte_idx</span>++], 
                                          <span class="i">chunk</span>.<span class="i">data</span>[<span class="i">byte_idx</span>++],
                                          <span class="n">255</span>)</span></span>;</span>
                        }</span></span></span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    <span class="lc">//color key or palette transparency</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">tRNS</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">length</span></span> == <span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{<span class="s Break"><span class="k">break</span>;</span>}</span></span></span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">color_key</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span>
                        <span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">color_type</span></span> == <span class="e Identifier"><span class="i">PNGColorType</span></span>.<span class="e Identifier"><span class="i">Palette</span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">chunk</span>.<span class="i">data</span>.<span class="i">length</span> &lt;= <span class="i">info</span>.<span class="i">palette</span>.<span class="i">length</span>, 
                                                     <span class="sl">"Palette too large"</span>)</span>;</span>
                            <span class="s Foreach"><span class="k">foreach</span>(<span class="o Parameters"><span class="o Parameter"><span class="i">index</span></span>, <span class="o Parameter"><span class="i">alpha</span></span></span>; <span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>)<span class="s Scope"><span class="s Compound">{<span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">palette</span></span>[<span class="e Identifier"><span class="i">index</span></span>]</span>.<span class="e Identifier"><span class="i">a</span></span> = <span class="e Identifier"><span class="i">alpha</span></span></span>;</span>}</span></span></span>
                        }</span></span>
                        <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">color_type</span></span> == <span class="e Identifier"><span class="i">PNGColorType</span></span>.<span class="e Identifier"><span class="i">RGB</span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">color_key_r</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ushort</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Int"><span class="n">256U</span></span> * <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">0</span></span>]</span></span> + <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">1</span></span>]</span></span>)</span></span></span>;</span>
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">color_key_g</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ushort</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Int"><span class="n">256U</span></span> * <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">2</span></span>]</span></span> + <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">3</span></span>]</span></span>)</span></span></span>;</span>
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">color_key_b</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ushort</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Int"><span class="n">256U</span></span> * <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">4</span></span>]</span></span> + <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">5</span></span>]</span></span>)</span></span></span>;</span>
                        }</span></span>
                        <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">color_type</span></span> == <span class="e Identifier"><span class="i">PNGColorType</span></span>.<span class="e Identifier"><span class="i">Greyscale</span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">color_key_r</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ushort</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Int"><span class="n">256U</span></span> * <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">0</span></span>]</span></span> + <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">1</span></span>]</span></span>)</span></span></span>;</span>
                        }</span></span>
                        <span class="k">else</span><span class="s Scope"><span class="s Compound">{<span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Bool"><span class="k">false</span></span>, <span class="e String"><span class="sl">"Transparency chunk not supported for this format"</span></span>)</span>;</span>}</span></span></span></span></span></span></span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    <span class="lc">//background color</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">bKGD</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s If"><span class="k">if</span>(<span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">color_type</span></span> == <span class="e Identifier"><span class="i">PNGColorType</span></span>.<span class="e Identifier"><span class="i">Palette</span></span></span> || 
                           <span class="e Equal"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bit_depth</span></span> == <span class="e Int"><span class="n">16</span></span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">background</span></span> = <span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">dup</span></span></span>;</span>
                        }</span></span>
                        <span class="k">else</span>
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">background</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Div"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>.<span class="e Identifier"><span class="i">length</span></span> / <span class="e Int"><span class="n">2</span></span></span></span>;</span>
                            <span class="s Foreach"><span class="k">foreach</span>(<span class="o Parameters"><span class="o Parameter"><span class="i">index</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="i">value</span></span></span>; <span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">background</span></span>)
                            <span class="s Scope"><span class="s Compound">{
                                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">value</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Mul"><span class="e Identifier"><span class="i">index</span></span> * <span class="e Int"><span class="n">2</span></span></span>]</span></span>;</span>
                            }</span></span></span>
                        }</span></span></span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    <span class="lc">//compressed text</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">zTXt</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">sep</span> = <span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="k">cast</span>(<span class="i">string</span>)<span class="i">chunk</span>.<span class="i">data</span>, <span class="n">0</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span>(<span class="e Rel"><span class="e Identifier"><span class="i">sep</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">sep</span></span> + <span class="e Int"><span class="n">1</span></span></span>]</span> == <span class="e Int"><span class="n">0</span></span></span>)
                            <span class="s Scope"><span class="s Compound">{
                                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">text</span></span>.<span class="e Identifier"><span class="i">latin</span></span>[<span class="e Slice"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">sep</span></span>]</span>]</span> = 
                                               <span class="e Slice"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">sep</span></span> + <span class="e Int"><span class="n">2</span></span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
                            }</span></span>
                            <span class="k">else</span>
                            <span class="s Scope"><span class="s Compound">{
                                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">text</span></span>.<span class="e Identifier"><span class="i">latin</span></span>[<span class="e Slice"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">sep</span></span>]</span>]</span> = 
                                                <span class="e Call"><span class="e Identifier"><span class="i">zlib_inflate</span></span>(<span class="i">chunk</span>.<span class="i">data</span>[<span class="i">sep</span> + <span class="n">2</span> .. $])</span></span>;</span>
                            }</span></span></span>
                        }</span></span></span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    <span class="lc">//text</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">tEXt</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">sep</span> = <span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="k">cast</span>(<span class="i">string</span>)<span class="i">chunk</span>.<span class="i">data</span>, <span class="n">0</span>)</span>;</span></span>
                        <span class="s If"><span class="k">if</span>(<span class="e Rel"><span class="e Identifier"><span class="i">sep</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">text</span></span>.<span class="e Identifier"><span class="i">latin</span></span>[<span class="e Slice"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">sep</span></span>]</span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">sep</span></span> + <span class="e Int"><span class="n">1</span></span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
                        }</span></span></span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    <span class="lc">//utf-8 text</span>
                    <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">iTXt</span></span>:
                        <span class="s Scope"><span class="s Compound"><span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">sep</span> = <span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="k">cast</span>(<span class="i">string</span>)<span class="i">chunk</span>.<span class="i">data</span>, <span class="n">0</span>)</span>;</span></span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">keyword</span> = <span class="e Slice"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">string</span></span>)<span class="e Identifier"><span class="i">chunk</span></span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">sep</span></span>]</span>;</span></span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">compressed</span> = <span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">bool</span></span>)<span class="e Identifier"><span class="i">chunk</span></span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">sep</span></span> + <span class="e Int"><span class="n">1</span></span></span>]</span>;</span></span>
                        <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">sep</span></span> += <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="k">cast</span>(<span class="i">string</span>)<span class="i">chunk</span>.<span class="i">data</span>[<span class="i">sep</span> + <span class="n">3</span> .. $], <span class="n">0</span>)</span> + <span class="e Int"><span class="n">3</span></span></span></span>;</span>
                        <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">sep</span></span> += <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="k">cast</span>(<span class="i">string</span>)<span class="i">chunk</span>.<span class="i">data</span>[<span class="i">sep</span> + <span class="n">1</span> .. $], <span class="n">0</span>)</span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
                        <span class="s If"><span class="k">if</span>(<span class="e Not">!<span class="e Identifier"><span class="i">compressed</span></span></span>)
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">text</span></span>.<span class="e Identifier"><span class="i">unicode</span></span>[<span class="e Identifier"><span class="i">keyword</span></span>]</span> = <span class="e Slice"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">string</span></span>)<span class="e Identifier"><span class="i">chunk</span></span></span>.<span class="e Identifier"><span class="i">data</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">sep</span></span> + <span class="e Int"><span class="n">1</span></span></span> .. <span class="e Dollar">$</span>]</span></span>;</span>
                        }</span></span>
                        <span class="k">else</span>
                        <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">text</span></span>.<span class="e Identifier"><span class="i">unicode</span></span>[<span class="e Identifier"><span class="i">keyword</span></span>]</span> = 
                                             <span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">string</span></span>)<span class="e Identifier"><span class="i">zlib_inflate</span></span></span>(<span class="i">chunk</span>.<span class="i">data</span>[<span class="i">sep</span> + <span class="n">1</span> .. $])</span></span>;</span>
                        }</span></span></span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                    <span class="s Default"><span class="k">default</span>:
                        <span class="lc">//size_t type = chunk.type;</span>
                        <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>((<span class="i">bt</span>(&amp;<span class="i">chunk</span>.<span class="i">type</span>, <span class="k">cast</span>(<span class="i">size_t</span>)<span class="n">6</span>) &lt; <span class="n">0</span>), 
                                   <span class="sl">"Unrecognized critical chunk"</span>)</span>;</span>
                        <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                }</span></span></span>
            }</span></span></span>

            <span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Identifier"><span class="i">info</span></span>.<span class="e Identifier"><span class="i">interlace</span></span> != <span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{<span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">deinterlace</span></span>(<span class="i">buffer</span>, <span class="i">info</span>.<span class="i">image</span>)</span>;</span>}</span></span>
            <span class="k">else</span><span class="s Scope"><span class="s Compound">{<span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">reconstruct</span></span>(<span class="i">buffer</span>, <span class="i">info</span>.<span class="i">image</span>)</span>;</span>}</span></span></span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">output</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">alloc</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>(<span class="i">buffer</span>.<span class="i">length</span>)</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">output</span></span>[]</span> = <span class="e Identifier"><span class="i">buffer</span></span>.<span class="e Identifier"><span class="i">array</span></span></span>;</span>

            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">output</span></span>;</span>
        }</span></span></span></span></span>
}</span></span>

<span class="d Protection"><span class="k">private</span></span>:
<span class="lc">///Size of a PNG header.</span>
<span class="d Compound"><span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">header_size</span> = <span class="e Int"><span class="n">34</span></span>;</span>

<span class="bc">/**
 * Parse a PNG header.
 *
 * Params:  source    = PNG data buffer.
 *          interlace = PNG interlacing method will be written here.
 *
 * Returns: PNGImage with header information.
 *
 * Throws:  PNGException if the header is invalid.
 */</span>
<span class="d Function"><span class="t Identifier"><span class="i">PNGImage</span></span> <span class="i">read_header</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="k">out</span> <span class="t Integral"><span class="k">ubyte</span></span> <span class="i">interlace</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">//spec: http://www.w3.org/TR/PNG/#11IHDR</span>

    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">source</span>.<span class="i">length</span> &gt;= <span class="i">header_size</span>, <span class="sl">"PNG header too small"</span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">source</span>[<span class="n">0</span> .. <span class="n">8</span>] == <span class="i">png_magic_number</span>, 
                             <span class="sl">"Invalid PNG header (PNG magic number does not match)"</span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">get_uint</span>(<span class="i">source</span>[<span class="n">12</span> .. <span class="n">16</span>]) == <span class="i">IHDR</span>, 
                             <span class="sl">"Invalid PNG header (Header name does not match)"</span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">zlib_check_crc</span>(<span class="i">get_uint</span>(<span class="i">source</span>[<span class="n">29</span> .. <span class="n">33</span>]), <span class="i">source</span>[<span class="n">12</span> .. <span class="n">29</span>]), 
                             <span class="sl">"Invalid PNG CRC (file might be corrupted?)"</span>)</span>;</span>

    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">PNGImage</span></span> <span class="i">result</span>;</span></span>
    <span class="s With"><span class="k">with</span>(<span class="e Identifier"><span class="i">result</span></span>)
    <span class="s Scope"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">width</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">get_uint</span></span>(<span class="i">source</span>[<span class="n">16</span> .. <span class="n">20</span>])</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">height</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">get_uint</span></span>(<span class="i">source</span>[<span class="n">20</span> .. <span class="n">24</span>])</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">bit_depth</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">source</span></span>[<span class="e Int"><span class="n">24</span></span>]</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">color_type</span></span> = <span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">PNGColorType</span></span>) <span class="e Identifier"><span class="i">source</span></span></span>[<span class="e Int"><span class="n">25</span></span>]</span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">source</span>[<span class="n">26</span>] == <span class="n">0</span>, 
                                 <span class="sl">"Unsupported compression method in PNG header"</span>)</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">source</span>[<span class="n">27</span>] == <span class="n">0</span>, 
                                 <span class="sl">"Unsupported filter method in PNG header"</span>)</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">validate_color</span>(<span class="i">color_type</span>, <span class="i">bit_depth</span>), 
                                 <span class="sl">"Invalid color format in PNG header"</span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">interlace</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">source</span></span>[<span class="e Int"><span class="n">28</span></span>]</span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">interlace</span> &lt; <span class="n">2</span>, 
                                 <span class="sl">"Invalid  interlace method in PNG header"</span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">bpp</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ubyte</span></span>)<span class="e Paren">(<span class="e Mul"><span class="e Call"><span class="e Identifier"><span class="i">num_channels</span></span>(<span class="i">color_type</span>)</span> * <span class="e Identifier"><span class="i">bit_depth</span></span></span>)</span></span></span>;</span>
    }</span></span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
}</span></span></span>

<span class="bc">/**
 * Estimate buffer size needed for decoding an image with specified parameters.
 *
 * Params:  image = Image to estimate buffer size for.
 *
 * Returns: Estimated buffer size. Not exact.
 */</span>
<span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">buffer_size</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">PNGImage</span></span> <span class="i">image</span></span>)</span><span class="s FuncBody"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Div"><span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">width</span></span> * <span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span></span> + <span class="e Int"><span class="n">7</span></span></span>)</span> / <span class="e Int"><span class="n">8</span></span></span>)</span> * <span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">height</span></span></span>;</span>}</span></span></span>

<span class="lc">///Iterator over PNG chunks. </span>
<span class="d Class"><span class="k">class</span> <span class="i">PNGChunkIterator</span> : <span class="t BaseClass"><span class="t TemplateInstance"><span class="i">Iterator</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGChunk</span></span>)</span></span></span>
<span class="d Compound">{
    <span class="d Protection"><span class="k">private</span></span>:
        <span class="lc">///PNG data stream (without header).</span>
        <span class="d Compound"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">stream_</span>;</span>

    <span class="d Protection"><span class="k">public</span></span>:
        <span class="lc">///Construct a PNGChunkIterator over specified stream (without header).</span>
        <span class="d Compound"><span class="d Constructor"><span class="k">this</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">stream</span></span>)</span><span class="s FuncBody"><span class="s Compound">{<span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">stream_</span></span> = <span class="e Identifier"><span class="i">stream</span></span></span>;</span>}</span></span></span>

        <span class="lc">///Iterate over chunks. Chunk will be destroyed after their respective iterations.</span>
        <span class="d StorageClass"><span class="k">override</span></span> <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">opApply</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">PNGChunk</span></span> <span class="i">chunk</span></span>)</span></span> <span class="i">visitor</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">result</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">pos</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
            <span class="s While"><span class="k">while</span>(<span class="e Rel"><span class="e Plus"><span class="e Identifier"><span class="i">pos</span></span> + <span class="e Identifier"><span class="i">chunk_min_size</span></span></span> &lt;= <span class="e Identifier"><span class="i">stream_</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">PNGChunk</span></span> <span class="i">chunk</span> = <span class="e Call"><span class="e Identifier"><span class="i">PNGChunk</span></span>.<span class="e Identifier"><span class="i">from_stream</span></span>(<span class="i">stream_</span>[<span class="i">pos</span> .. $])</span>;</span></span>
                <span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">type</span></span> == <span class="e Identifier"><span class="i">IEND</span></span></span>)<span class="s Scope"><span class="s Compound">{<span class="s Break"><span class="k">break</span>;</span>}</span></span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">visitor</span></span>(<span class="i">chunk</span>)</span></span>;</span>
                <span class="s If"><span class="k">if</span>(<span class="e Identifier"><span class="i">result</span></span>)<span class="s Scope"><span class="s Compound">{<span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>}</span></span></span>
                <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">pos</span></span> += <span class="e Identifier"><span class="i">chunk</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
        }</span></span></span></span></span>
}</span></span>

<span class="bc">/**
 * Unapply a filter on a line of image data.
 *
 * Params:  result      = Filtered result will be written here.
 *          line        = Current line in the image. Must not overlap with result.
 *          previous    = Previous, already filtered, line in the image. 
 *                        Must not overlap with result.
 *          pixel_bytes = Pixel size in bytes (1 if actual pixel size is below 1 byte).
 *          filter      = Filter to unapply.
 */</span>
<span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">unfilter_line</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">result</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">line</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">previous</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">pixel_bytes</span></span>,
                   <span class="o Parameter"><span class="t Identifier"><span class="i">PNGFilter</span></span> <span class="i">filter</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Switch"><span class="k">switch</span>(<span class="e Identifier"><span class="i">filter</span></span>)
    <span class="s Scope"><span class="s Compound">{
        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">PNGFilter</span></span>.<span class="e Identifier"><span class="i">Paeth</span></span>:
            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">line</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Identifier"><span class="i">line</span></span></span>;</span>
            <span class="lc">//first pixel</span>
            <span class="s Expression"><span class="e PlusAssign"><span class="e Slice"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">pixel_bytes</span></span>]</span> += <span class="e Slice"><span class="e Identifier"><span class="i">previous</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">pixel_bytes</span></span>]</span></span>;</span>

            <span class="lc">//i is current pixel in this and previous line</span>
            <span class="lc">//o is previous pixel in this and previous line</span>
            <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">i</span> = <span class="e Identifier"><span class="i">pixel_bytes</span></span>, <span class="i">o</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">line</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>; <span class="e Comma"><span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span>, <span class="e PostIncr"><span class="e Identifier"><span class="i">o</span></span>++</span></span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e PlusAssign"><span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> += <span class="e Call"><span class="e Identifier"><span class="i">paeth_predictor</span></span>(<span class="i">result</span>[<span class="i">o</span>], <span class="i">previous</span>[<span class="i">i</span>], <span class="i">previous</span>[<span class="i">o</span>])</span></span>;</span>
            }</span></span></span>
            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">PNGFilter</span></span>.<span class="e Identifier"><span class="i">Average</span></span>:
            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">line</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">line</span></span>[]</span></span>;</span>
            <span class="lc">//first pixel</span>
            <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">pixel_bytes</span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span>)<span class="s Scope"><span class="s Compound">{<span class="s Expression"><span class="e PlusAssign"><span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> += <span class="e Div"><span class="e Index"><span class="e Identifier"><span class="i">previous</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> / <span class="e Int"><span class="n">2</span></span></span></span>;</span>}</span></span></span>
            <span class="lc">//rest of the line</span>
            <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">i</span> = <span class="e Identifier"><span class="i">pixel_bytes</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">line</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e PlusAssign"><span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> += <span class="e Div"><span class="e Paren">(<span class="e Plus"><span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Identifier"><span class="i">pixel_bytes</span></span></span>]</span> + <span class="e Index"><span class="e Identifier"><span class="i">previous</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span></span>)</span> / <span class="e Int"><span class="n">2</span></span></span></span>;</span>
            }</span></span></span>
            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">PNGFilter</span></span>.<span class="e Identifier"><span class="i">Up</span></span>:
            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">line</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Plus"><span class="e Slice"><span class="e Identifier"><span class="i">line</span></span>[]</span> + <span class="e Slice"><span class="e Identifier"><span class="i">previous</span></span>[]</span></span></span>;</span>
            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">PNGFilter</span></span>.<span class="e Identifier"><span class="i">Sub</span></span>:
            <span class="lc">//first pixel</span>
            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">pixel_bytes</span></span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">line</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">pixel_bytes</span></span>]</span></span>;</span>
            <span class="lc">//rest of the line</span>
            <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">i</span> = <span class="e Identifier"><span class="i">pixel_bytes</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Identifier"><span class="i">line</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">i</span></span>++</span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> = <span class="e Plus"><span class="e Index"><span class="e Identifier"><span class="i">line</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> + <span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Identifier"><span class="i">pixel_bytes</span></span></span>]</span></span></span>;</span>
            }</span></span></span>
            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
        <span class="s Case"><span class="k">case</span> <span class="e Identifier"><span class="i">PNGFilter</span></span>.<span class="e Identifier"><span class="i">None</span></span>:
            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Identifier"><span class="i">line</span></span>.<span class="e Identifier"><span class="i">length</span></span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">line</span></span>[]</span></span>;</span>
            <span class="s Break"><span class="k">break</span>;</span></span></span></span>
        <span class="s Default"><span class="k">default</span>:
            <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Bool"><span class="k">false</span></span>, <span class="e String"><span class="sl">"Invalid PNG filter."</span></span>)</span>;</span></span></span></span>
    }</span></span></span>
}</span></span></span>

<span class="bc">/**
 * Deinterlace Adam7 interlaced data.
 *
 * Params:  buffer = Interlaced data will be read from here and deinterlaced data 
 *                   will be written here.
 *          image  = Image information.
 */</span>
<span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">deinterlace</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t TemplateInstance"><span class="i">Vector</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span> <span class="i">buffer</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">PNGImage</span></span> <span class="i">image</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">//result buffer</span>
    <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">result</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">Vector</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>()</span>;</span></span>
    <span class="s ScopeGuard"><span class="k">scope</span>(<span class="i">exit</span>)<span class="s Scope"><span class="s Compound">{<span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">die</span></span>()</span>;</span>}</span></span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">buffer_size</span></span>(<span class="i">image</span>)</span></span>;</span>

    <span class="bc">/**
     * Perform an adam7 deinterlacing pass.
     *
     * Params:  source = Source interlaced data.
     *          start  = Offset of the first deinterlaced pixel.
     *          dist   = Distance of deinterlaced pixels in the final image, e.g.
     *                   size equal to Vector2u(8, 8) means deinterlace 
     *                   every pixel is placed 8 pixels from previous one,
     *                   horizontally or vertically.
     *          dim    = Dimensions of interlaced data.
     */</span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">adam7_pass</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Vector2u</span></span> <span class="i">start</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Vector2u</span></span> <span class="i">dist</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Vector2u</span></span> <span class="i">dim</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">pixel_bytes</span> = <span class="e Div"><span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> + <span class="e Int"><span class="n">7</span></span></span>)</span> / <span class="e Int"><span class="n">8</span></span></span>;</span></span> <span class="lc">// pixel_bytes is used for filtering</span>
        <span class="lc">//previous line</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">previous</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[<span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">width</span></span> * <span class="e Identifier"><span class="i">pixel_bytes</span></span></span>]</span></span>;</span></span>
        <span class="lc">//current line</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">line</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[<span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">width</span></span> * <span class="e Identifier"><span class="i">pixel_bytes</span></span></span>]</span></span>;</span></span>

        <span class="lc">///Place pixels from the current line to result. line_idx is index of the current line.</span>
        <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">place_pixels</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">line_idx</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="lc">//ineffective, but relatively readable</span>
            <span class="lc">//pixels of the line</span>
            <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">px</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">px</span></span> &lt; <span class="e Identifier"><span class="i">dim</span></span>.<span class="e Identifier"><span class="i">x</span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">px</span></span>++</span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="lc">//pixel offset in result without pixel size applied</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">offset</span> = <span class="e Plus"><span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">width</span></span> * <span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">start</span></span>.<span class="e Identifier"><span class="i">y</span></span> + <span class="e Mul"><span class="e Identifier"><span class="i">dist</span></span>.<span class="e Identifier"><span class="i">y</span></span> * <span class="e Identifier"><span class="i">line_idx</span></span></span></span>)</span></span> + <span class="e Identifier"><span class="i">start</span></span>.<span class="e Identifier"><span class="i">x</span></span></span> + <span class="e Mul"><span class="e Identifier"><span class="i">dist</span></span>.<span class="e Identifier"><span class="i">x</span></span> * <span class="e Identifier"><span class="i">px</span></span></span></span>;</span></span>
                <span class="lc">//working with bytes</span>
                <span class="s If"><span class="k">if</span>(<span class="e Rel"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> &gt;= <span class="e Int"><span class="n">8</span></span></span>)
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">//offset of this pixel in result</span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">r</span> = <span class="e Mul"><span class="e Identifier"><span class="i">pixel_bytes</span></span> * <span class="e Identifier"><span class="i">offset</span></span></span>;</span></span>
                    <span class="lc">//offset of this pixel in line</span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">l</span> = <span class="e Mul"><span class="e Identifier"><span class="i">pixel_bytes</span></span> * <span class="e Identifier"><span class="i">px</span></span></span>;</span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Identifier"><span class="i">r</span></span> .. <span class="e Plus"><span class="e Identifier"><span class="i">r</span></span> + <span class="e Identifier"><span class="i">pixel_bytes</span></span></span>]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">line</span></span>[<span class="e Identifier"><span class="i">l</span></span> .. <span class="e Plus"><span class="e Identifier"><span class="i">l</span></span> + <span class="e Identifier"><span class="i">pixel_bytes</span></span></span>]</span></span>;</span>
                }</span></span>
                <span class="lc">//untested, might not work</span>
                <span class="lc">//working with bits</span>
                <span class="k">else</span>
                <span class="s Scope"><span class="s Compound">{
                    <span class="lc">//offset of this pixel in bits, not bytes, in result</span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">px_start</span> = <span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> * <span class="e Identifier"><span class="i">offset</span></span></span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">px_end</span> = <span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> * <span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">offset</span></span> + <span class="e Int"><span class="n">1</span></span></span>)</span></span>;</span></span>
                    <span class="lc">//offset of this pixel in bits, not bytes, in line</span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">px_start_line</span> = <span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> * <span class="e Identifier"><span class="i">px</span></span></span>;</span></span>
                    
                    <span class="lc">//bits in the pixel - r in result, b in line</span>
                    <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">r</span> = <span class="e Identifier"><span class="i">px_start</span></span>, <span class="i">l</span> = <span class="e Identifier"><span class="i">px_start_line</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">r</span></span> &lt; <span class="e Identifier"><span class="i">px_end</span></span></span>; <span class="e Comma"><span class="e PostIncr"><span class="e Identifier"><span class="i">r</span></span>++</span>, <span class="e PostIncr"><span class="e Identifier"><span class="i">l</span></span>++</span></span>)
                    <span class="s Scope"><span class="s Compound">{
                        <span class="lc">//bit position in result - 0 is the LSB, 7 is MSB of a byte</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">rbitpos</span> = <span class="e Minus"><span class="e Int"><span class="n">7</span></span> - <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">r</span></span> &amp; <span class="e Int"><span class="n">0x7</span></span></span>)</span></span>;</span></span>
                        <span class="lc">//bit position in line - 0 is the LSB, 7 is MSB of a byte</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">lbitpos</span> = <span class="e Minus"><span class="e Int"><span class="n">7</span></span> - <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">l</span></span> &amp; <span class="e Int"><span class="n">0x7</span></span></span>)</span></span>;</span></span>
                        <span class="lc">//bit value</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">_bit</span> = <span class="e And"><span class="e Paren">(<span class="e RShift"><span class="e Index"><span class="e Identifier"><span class="i">line</span></span>[<span class="e Div"><span class="e Identifier"><span class="i">l</span></span> / <span class="e Int"><span class="n">8</span></span></span>]</span> &gt;&gt; <span class="e Identifier"><span class="i">lbitpos</span></span></span>)</span> &amp; <span class="e Int"><span class="n">1</span></span></span>;</span></span>
                        <span class="lc">//index of this byte in result</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">byte_idx</span> = <span class="e Div"><span class="e Identifier"><span class="i">r</span></span> / <span class="e Int"><span class="n">8</span></span></span>;</span></span>
                        <span class="lc">//set the bit</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Identifier"><span class="i">byte_idx</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ubyte</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Paren">(<span class="e And"><span class="e Index"><span class="e Identifier"><span class="i">result</span></span>[<span class="e Identifier"><span class="i">byte_idx</span></span>]</span> &amp; <span class="e Comp">~<span class="e Paren">(<span class="e LShift"><span class="e Int"><span class="n">1</span></span> &lt;&lt; <span class="e Identifier"><span class="i">rbitpos</span></span></span>)</span></span></span>)</span> 
                                                      | <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">_bit</span></span> &lt;&lt; <span class="e Identifier"><span class="i">rbitpos</span></span></span>)</span></span>)</span></span></span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span></span></span>
        }</span></span></span></span>

        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">line_length</span> = <span class="e Plus"><span class="e Int"><span class="n">1</span></span> + <span class="e Paren">(<span class="e Div"><span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> * <span class="e Identifier"><span class="i">dim</span></span>.<span class="e Identifier"><span class="i">x</span></span></span> + <span class="e Int"><span class="n">7</span></span></span>)</span> / <span class="e Int"><span class="n">8</span></span></span>)</span></span>;</span></span>
        <span class="lc">//previous line to the first line is a zero line</span>
        <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">previous</span></span>[]</span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
        <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">line_idx</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">line_idx</span></span> &lt; <span class="e Identifier"><span class="i">dim</span></span>.<span class="e Identifier"><span class="i">y</span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">line_idx</span></span>++</span>)
        <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">line_start</span> = <span class="e Mul"><span class="e Identifier"><span class="i">line_idx</span></span> * <span class="e Identifier"><span class="i">line_length</span></span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">PNGFilter</span></span> <span class="i">filter</span> = <span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">PNGFilter</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>[<span class="e Identifier"><span class="i">line_start</span></span>]</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">source_line</span> = <span class="e Slice"><span class="e Identifier"><span class="i">source</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">line_start</span></span> + <span class="e Int"><span class="n">1</span></span></span> .. <span class="e Plus"><span class="e Identifier"><span class="i">line_start</span></span> + <span class="e Identifier"><span class="i">line_length</span></span></span>]</span>;</span></span>

            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">unfilter_line</span></span>(<span class="i">line</span>, <span class="i">source_line</span>, <span class="i">previous</span>, <span class="i">pixel_bytes</span>, <span class="i">filter</span>)</span>;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">place_pixels</span></span>(<span class="i">line_idx</span>);</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">swap</span></span>(<span class="i">line</span>, <span class="i">previous</span>)</span>;</span>
        }</span></span></span>
    }</span></span></span></span>

    <span class="lc">//dimensions of data for each pass</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Vector2u</span></span><span class="t Array">[<span class="e Int"><span class="n">7</span></span>]</span> <span class="i">pass_dim</span> = <span class="e ArrayInit">[<span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>((<span class="i">image</span>.<span class="i">width</span> + <span class="n">7</span>) / <span class="n">8</span>, (<span class="i">image</span>.<span class="i">height</span> + <span class="n">7</span>) / <span class="n">8</span>)</span>,
                            <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>((<span class="i">image</span>.<span class="i">width</span> + <span class="n">3</span>) / <span class="n">8</span>, (<span class="i">image</span>.<span class="i">height</span> + <span class="n">7</span>) / <span class="n">8</span>)</span>,
                            <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>((<span class="i">image</span>.<span class="i">width</span> + <span class="n">3</span>) / <span class="n">4</span>, (<span class="i">image</span>.<span class="i">height</span> + <span class="n">3</span>) / <span class="n">8</span>)</span>,
                            <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>((<span class="i">image</span>.<span class="i">width</span> + <span class="n">1</span>) / <span class="n">4</span>, (<span class="i">image</span>.<span class="i">height</span> + <span class="n">3</span>) / <span class="n">4</span>)</span>,
                            <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>((<span class="i">image</span>.<span class="i">width</span> + <span class="n">1</span>) / <span class="n">2</span>, (<span class="i">image</span>.<span class="i">height</span> + <span class="n">1</span>) / <span class="n">4</span>)</span>,
                            <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>((<span class="i">image</span>.<span class="i">width</span> + <span class="n">0</span>) / <span class="n">2</span>, (<span class="i">image</span>.<span class="i">height</span> + <span class="n">1</span>) / <span class="n">2</span>)</span>,
                            <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>((<span class="i">image</span>.<span class="i">width</span> + <span class="n">0</span>) / <span class="n">1</span>, (<span class="i">image</span>.<span class="i">height</span> + <span class="n">0</span>) / <span class="n">2</span>)</span>]</span>;</span></span>

    <span class="lc">//starting pixel for each pass</span>
    <span class="s Declaration"><span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">Vector2u</span></span><span class="t Array">[<span class="e Int"><span class="n">7</span></span>]</span> <span class="i">pass_start</span> = <span class="e ArrayInit">[<span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">0</span>, <span class="n">0</span>)</span>,
                                    <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">4</span>, <span class="n">0</span>)</span>,
                                    <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">0</span>, <span class="n">4</span>)</span>,
                                    <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">2</span>, <span class="n">0</span>)</span>,
                                    <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">0</span>, <span class="n">2</span>)</span>,
                                    <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">1</span>, <span class="n">0</span>)</span>,
                                    <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">0</span>, <span class="n">1</span>)</span>]</span>;</span></span>
                    
    <span class="lc">//distance between deinterlaced pixels for each pass</span>
    <span class="s Declaration"><span class="d StorageClass"><span class="k">const</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">Vector2u</span></span><span class="t Array">[<span class="e Int"><span class="n">7</span></span>]</span> <span class="i">pass_dist</span> = <span class="e ArrayInit">[<span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">8</span>, <span class="n">8</span>)</span>,
                                   <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">8</span>, <span class="n">8</span>)</span>,
                                   <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">4</span>, <span class="n">8</span>)</span>,
                                   <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">4</span>, <span class="n">4</span>)</span>,
                                   <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">2</span>, <span class="n">4</span>)</span>,
                                   <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">2</span>, <span class="n">2</span>)</span>,
                                   <span class="e Call"><span class="e Identifier"><span class="i">Vector2u</span></span>(<span class="n">1</span>, <span class="n">2</span>)</span>]</span>;</span></span> 

    <span class="lc">//adam7 passes. offset is start of the pass in source</span>
    <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">p</span> = <span class="e Int"><span class="n">0</span></span>, <span class="i">offset</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">p</span></span> &lt; <span class="e Int"><span class="n">7</span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">p</span></span>++</span>)
    <span class="s Scope"><span class="s Compound">{
        <span class="lc">//empty pass</span>
        <span class="s If"><span class="k">if</span>(<span class="e Equal"><span class="e Mul"><span class="e Index"><span class="e Identifier"><span class="i">pass_dim</span></span>[<span class="e Identifier"><span class="i">p</span></span>]</span>.<span class="e Identifier"><span class="i">y</span></span> * <span class="e Index"><span class="e Identifier"><span class="i">pass_dim</span></span>[<span class="e Identifier"><span class="i">p</span></span>]</span>.<span class="e Identifier"><span class="i">x</span></span></span> == <span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{<span class="s Continue"><span class="k">continue</span>;</span>}</span></span></span>

        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">adam7_pass</span></span>(<span class="i">buffer</span>[<span class="i">offset</span> .. <span class="i">buffer</span>.<span class="i">length</span>], <span class="i">pass_start</span>[<span class="i">p</span>], <span class="i">pass_dist</span>[<span class="i">p</span>], <span class="i">pass_dim</span>[<span class="i">p</span>])</span>;</span>

        <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">offset</span></span> += <span class="e Paren">(<span class="e Mul"><span class="e Index"><span class="e Identifier"><span class="i">pass_dim</span></span>[<span class="e Identifier"><span class="i">p</span></span>]</span>.<span class="e Identifier"><span class="i">y</span></span> * <span class="e Paren">(<span class="e Plus"><span class="e Int"><span class="n">1</span></span> + <span class="e Div"><span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Index"><span class="e Identifier"><span class="i">pass_dim</span></span>[<span class="e Identifier"><span class="i">p</span></span>]</span>.<span class="e Identifier"><span class="i">x</span></span> * <span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span></span> + <span class="e Int"><span class="n">7</span></span></span>)</span> / <span class="e Int"><span class="n">8</span></span></span></span>)</span></span>)</span></span>;</span>
    }</span></span></span>

    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">buffer</span></span> = <span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">array</span></span></span>;</span>
}</span></span></span>

<span class="bc">/**
 * Reconstruct image from PNG (non-interlaced) data.
 *
 * PNG image data, when uncompressed, has a byte specifying filter before each
 * line and the line is filtered using that filter.
 * This will unapply the filter and pack lines together.
 *
 * Params:  buffer = PNG data will be read from here and output will be written here.
 *                   This might be done in place.
 *          image  = Information about the image.
 */</span>
<span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">reconstruct</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t TemplateInstance"><span class="i">Vector</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span> <span class="i">buffer</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">PNGImage</span></span> <span class="i">image</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">//we can work with the array directly as we do this in place</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">data</span> = <span class="e Identifier"><span class="i">buffer</span></span>.<span class="e Identifier"><span class="i">array</span></span>;</span></span>

    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">pixel_bytes</span> = <span class="e Div"><span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> + <span class="e Int"><span class="n">7</span></span></span>)</span> / <span class="e Int"><span class="n">8</span></span></span>;</span></span>
    <span class="lc">//bits are tightly packed, but lines are always padded to 1 byte boundaries</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">line_length</span> = <span class="e Div"><span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">width</span></span> * <span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span></span>)</span> + <span class="e Int"><span class="n">7</span></span></span>)</span> / <span class="e Int"><span class="n">8</span></span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">enforceEx</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">PNGException</span></span>)</span></span>(<span class="i">data</span>.<span class="i">length</span> &gt;= (<span class="i">line_length</span> + <span class="n">1</span>) * <span class="i">image</span>.<span class="i">height</span>, <span class="sl">"Invalid size of source data"</span>)</span>;</span>

    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">previous</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[<span class="e Identifier"><span class="i">line_length</span></span></span>]</span>;</span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">previous</span></span>[]</span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">line</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[<span class="e Identifier"><span class="i">line_length</span></span></span>]</span>;</span></span>

    <span class="lc">//working with bytes</span>
    <span class="s If"><span class="k">if</span>(<span class="e Rel"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span> &gt;= <span class="e Int"><span class="n">8</span></span></span>)
    <span class="s Scope"><span class="s Compound">{
        <span class="lc">//iterating over lines</span>
        <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">l</span> = <span class="e Int"><span class="n">0</span></span>, <span class="i">line_start</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">l</span></span> &lt; <span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">height</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">l</span></span></span>)
        <span class="s Scope"><span class="s Compound">{
            <span class="lc">//line is preceded by a byte specifying filter used</span>
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">filter</span> = <span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">PNGFilter</span></span>)<span class="e Identifier"><span class="i">data</span></span></span>[<span class="e Identifier"><span class="i">line_start</span></span>]</span>;</span></span>
            <span class="lc">//copy from data to line to avoid sending overlapping arrays to unfilter_line</span>
            <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">line</span></span>[]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">line_start</span></span> + <span class="e Int"><span class="n">1</span></span></span> .. <span class="e Plus"><span class="e Plus"><span class="e Identifier"><span class="i">line_start</span></span> + <span class="e Int"><span class="n">1</span></span></span> + <span class="e Identifier"><span class="i">line_length</span></span></span>]</span></span>;</span>
            <span class="lc">//line_start - 1 :in output, lines are packed together, we get rid of the filter bit</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">unfilter_line</span></span>(<span class="i">data</span>[<span class="i">line_start</span> - <span class="i">l</span> .. $], <span class="i">line</span>, <span class="i">previous</span>, <span class="i">pixel_bytes</span>, <span class="i">filter</span>)</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">previous</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">line_start</span></span> - <span class="e Identifier"><span class="i">l</span></span></span> .. <span class="e Dollar">$</span>]</span></span>;</span> 
            <span class="lc">//go to start of next line</span>
            <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">line_start</span></span> += <span class="e Plus"><span class="e Int"><span class="n">1</span></span> + <span class="e Identifier"><span class="i">line_length</span></span></span></span>;</span>
        }</span></span></span>
    }</span></span>
    <span class="lc">//untested, might not work</span>
    <span class="lc">//working with bits</span>
    <span class="k">else</span>
    <span class="s Scope"><span class="s Compound">{
        <span class="lc">//index if bit (not byte) in output</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">obit</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
        <span class="lc">//temp line</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">temp</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[<span class="e Identifier"><span class="i">line_length</span></span></span>]</span>;</span></span>

        <span class="lc">//iterating over lines</span>
        <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">l</span> = <span class="e Int"><span class="n">0</span></span>, <span class="i">line_start</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">l</span></span> &lt; <span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">height</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">l</span></span></span>)
        <span class="s Scope"><span class="s Compound">{
            <span class="lc">//line is preceded by a byte specifying filter used</span>
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">filter</span> = <span class="e Index"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">PNGFilter</span></span>)<span class="e Identifier"><span class="i">data</span></span></span>[<span class="e Identifier"><span class="i">line_start</span></span>]</span>;</span></span>
            <span class="lc">//copy from data to line to avoid sending overlapping arrays to unfilter_line</span>
            <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">line</span></span>[]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Plus"><span class="e Identifier"><span class="i">line_start</span></span> + <span class="e Int"><span class="n">1</span></span></span> .. <span class="e Plus"><span class="e Plus"><span class="e Identifier"><span class="i">line_start</span></span> + <span class="e Int"><span class="n">1</span></span></span> + <span class="e Identifier"><span class="i">line_length</span></span></span>]</span></span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">unfilter_line</span></span>(<span class="i">temp</span>, <span class="i">line</span>, <span class="i">previous</span>, <span class="i">pixel_bytes</span>, <span class="i">filter</span>)</span>;</span>

            <span class="lc">//tbit is bit in temp line</span>
            <span class="s For"><span class="k">for</span>(<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">tbit</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">tbit</span></span> &lt; <span class="e Mul"><span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">width</span></span> * <span class="e Identifier"><span class="i">image</span></span>.<span class="e Identifier"><span class="i">bpp</span></span></span></span>; <span class="e PostIncr"><span class="e Identifier"><span class="i">tbit</span></span>++</span>)
            <span class="s Scope"><span class="s Compound">{
                <span class="lc">//bit position in result - 0 is the LSB, 7 is MSB of a byte</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">obitpos</span> = <span class="e Minus"><span class="e Int"><span class="n">7</span></span> - <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">obit</span></span> &amp; <span class="e Int"><span class="n">0x7</span></span></span>)</span></span>;</span></span>
                <span class="lc">//bit position in temp line - 0 is the LSB, 7 is MSB of a byte</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">tbitpos</span> = <span class="e Minus"><span class="e Int"><span class="n">7</span></span> - <span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">tbit</span></span> &amp; <span class="e Int"><span class="n">0x7</span></span></span>)</span></span>;</span></span>
                <span class="lc">//bit value</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">_bit</span> = <span class="e And"><span class="e Paren">(<span class="e RShift"><span class="e Index"><span class="e Identifier"><span class="i">temp</span></span>[<span class="e Div"><span class="e Identifier"><span class="i">tbit</span></span> / <span class="e Int"><span class="n">8</span></span></span>]</span> &gt;&gt; <span class="e Identifier"><span class="i">tbitpos</span></span></span>)</span> &amp; <span class="e Int"><span class="n">1</span></span></span>;</span></span>
                <span class="lc">//index of this byte in output</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">byte_idx</span> = <span class="e Div"><span class="e Identifier"><span class="i">obit</span></span> / <span class="e Int"><span class="n">8</span></span></span>;</span></span>
                <span class="lc">//set the bit</span>
                <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Identifier"><span class="i">byte_idx</span></span>]</span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ubyte</span></span>)<span class="e Paren">(<span class="e Or"><span class="e Paren">(<span class="e And"><span class="e Index"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Identifier"><span class="i">byte_idx</span></span>]</span> &amp; <span class="e Comp">~<span class="e Paren">(<span class="e LShift"><span class="e Int"><span class="n">1</span></span> &lt;&lt; <span class="e Identifier"><span class="i">obitpos</span></span></span>)</span></span></span>)</span> 
                                               | <span class="e Paren">(<span class="e LShift"><span class="e Identifier"><span class="i">_bit</span></span> &lt;&lt; <span class="e Identifier"><span class="i">obitpos</span></span></span>)</span></span>)</span></span></span>;</span>
                <span class="s Expression"><span class="e PostIncr"><span class="e Identifier"><span class="i">obit</span></span>++</span>;</span>
            }</span></span></span>

            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">previous</span></span> = <span class="e Slice"><span class="e Identifier"><span class="i">data</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">line_start</span></span> - <span class="e Identifier"><span class="i">l</span></span></span> .. <span class="e Dollar">$</span>]</span></span>;</span> 
            <span class="lc">//go to start of next line</span>
            <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">line_start</span></span> += <span class="e Plus"><span class="e Int"><span class="n">1</span></span> + <span class="e Identifier"><span class="i">line_length</span></span></span></span>;</span>
        }</span></span></span>
    }</span></span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">buffer</span></span>.<span class="e Identifier"><span class="i">length</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">buffer_size</span></span>(<span class="i">image</span>)</span></span>;</span> 
}</span></span></span></span></span></span>

</pre></td>
</tr></table>
</body>
</html>