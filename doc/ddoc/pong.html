<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>pong</title>
        </head><body>
        <h1>pong</h1>
        <!-- Generated by Ddoc from pong.d -->
<br><br>
<dl><dt><big>class <u>Wall</u>: scene.actor.Actor;
</big></dt>
<dd>A rectangular wall in the game area.<br><br>

<dl><dt><big>void <u>velocity</u>(Vector2f <i>v</i>);
</big></dt>
<dd>Set wall <u>velocity</u>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>WallFactoryBase</u>(T): ActorFactory!(T);
</big></dt>
<dd>Base class for factories constructing Wall and derived classes.
<br><br>
<b>Params:</b><br>
<table><tr><td>box_min</td>
<td>Minimum extent of the wall relative to its position.</td></tr>
</table><br>
<b>Default:</b><br>
Vector2f(0.0f, 0.0f)
          box_max = Maximum extent of the wall relative to its position.
<br><br>
<b>Default:</b><br>
Vector2f(1.0f, 1.0f)<br><br>

</dd>
<dt><big>class <u>WallFactory</u>: pong.WallFactoryBase!(Wall).WallFactoryBase;
</big></dt>
<dd>Factory used to construct walls.<br><br>

</dd>
<dt><big>class <u>PaddleBody</u>: physics.physicsbody.PhysicsBody;
</big></dt>
<dd>Physics body of a paddle.
<br><br>
Contains functionality to make Arkanoid style ball reflection possible.<br><br>

<dl><dt><big>Vector2f <u>reflected_ball_velocity</u>(BallBody <i>ball</i>);
</big></dt>
<dd>Return velocity to reflect given BallBody at.
<br><br>
Used by BallBody collision response.

<br><br>
<b>Params:</b><br>
<table><tr><td>BallBody <i>ball</i></td>
<td>BallBody to reflect.</td></tr>
</table><br>
<b>Returns:</b><br>
Velocity the BallBody should be reflected at.<br><br>

</dd>
<dt><big>Rectanglef <u>limits</u>();
</big></dt>
<dd>Return <u>limits</u> of movement of this paddle body.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Paddle</u>: pong.Wall;
</big></dt>
<dd>A paddle controlled by a player or AI.<br><br>

<dl><dt><big>Rectanglef <u>limits</u>();
</big></dt>
<dd>Return <u>limits</u> of movement of this paddle.<br><br>

</dd>
<dt><big>void <u>move_right</u>();
</big></dt>
<dd>Control the paddle to move right (used by player or AI).<br><br>

</dd>
<dt><big>void <u>move_left</u>();
</big></dt>
<dd>Control the paddle to move left (used by player or AI).<br><br>

</dd>
<dt><big>void <u>stop</u>();
</big></dt>
<dd>Control the paddle to <u>stop</u> (used by player or AI).<br><br>

</dd>
<dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy the paddle.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>PaddleFactory</u>: pong.WallFactoryBase!(Paddle).WallFactoryBase;
</big></dt>
<dd>Factory used to construct paddles.
<br><br>
<b>Params:</b><br>
<table><tr><td>limits_min</td>
<td>Minimum extent of paddle movement limits in world space.</td></tr>
</table><br>
<b>Default:</b><br>
Vector2f(-2.0f, -2.0f)
          limits_max = Maximum extent of paddle movement limits in world space.
<br><br>
<b>Default:</b><br>
Vector2f(2.0f, 2.0f)
          speed      = Speed of paddle movement.
<br><br>
<b>Default:</b><br>
135.0<br><br>

</dd>
<dt><big>class <u>BallBody</u>: physics.physicsbody.PhysicsBody;
</big></dt>
<dd>Physics body of a ball.
<br><br>
Overrides default collision response to get Arkanoid style ball behavior.<br><br>

<dl><dt><big>float <u>radius</u>();
</big></dt>
<dd>Returns <u>radius</u> of this ball body for drawing.<br><br>

</dd>
<dt><big>this(VolumeCircle <i>circle</i>, Vector2f <i>position</i>, Vector2f <i>velocity</i>, real <i>mass</i>, float <i>radius</i>);
</big></dt>
<dd>Construct a ball body with specified parameters.
<br><br>
<b>Params:</b><br>
<table><tr><td>VolumeCircle <i>circle</i></td>
<td>Collision <i>circle</i> of the ball.</td></tr>
<tr><td>Vector2f <i>position</i></td>
<td>Starting <i>position</i> of the body.</td></tr>
<tr><td>Vector2f <i>velocity</i></td>
<td>Starting <i>velocity</i> of the body.</td></tr>
<tr><td>real <i>mass</i></td>
<td>Mass of the body.</td></tr>
<tr><td>float <i>radius</i></td>
<td>Radius of a <i>circle</i> representing bounding <i>circle</i>
                     of this body (centered at body's <i>position</i>).</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big>class <u>DummyBallBody</u>: pong.BallBody;
</big></dt>
<dd>Physics body of a dummy ball.
<br><br>
Limits dummy ball speed to prevent it being thrown out of the gameplay
 area after collision with a ball. (normal ball has no limits- it's speed
 can change, slightly, by collisions with dummy balls)<br><br>

<dl><dt><big>this(VolumeCircle <i>circle</i>, Vector2f <i>position</i>, Vector2f <i>velocity</i>, real <i>mass</i>, float <i>radius</i>);
</big></dt>
<dd>Construct a dummy ball body with specified parameters.
<br><br>
<b>Params:</b><br>
<table><tr><td>VolumeCircle <i>circle</i></td>
<td>Collision <i>circle</i> of the body.</td></tr>
<tr><td>Vector2f <i>position</i></td>
<td>Starting <i>position</i> of the body.</td></tr>
<tr><td>Vector2f <i>velocity</i></td>
<td>Starting <i>velocity</i> of the body.</td></tr>
<tr><td>real <i>mass</i></td>
<td>Mass of the body.</td></tr>
<tr><td>float <i>radius</i></td>
<td>Radius of a <i>circle</i> representing bounding <i>circle</i>
                     of this body (centered at body's <i>position</i>).</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Ball</u>: scene.actor.Actor;
</big></dt>
<dd>A ball that can bounce off other objects.<br><br>

<dl><dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy this ball.<br><br>

</dd>
<dt><big>float <u>radius</u>();
</big></dt>
<dd>Return the <u>radius</u> of this ball.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>BallFactory</u>: scene.actor.ActorFactory!(Ball).ActorFactory;
</big></dt>
<dd>Factory used to produce balls.
<br><br>
<b>Params:</b><br>
<table><tr><td>radius</td>
<td>Radius of the ball.</td></tr>
</table><br>
<b>Default:</b><br>
Vector2f(-2.0f, -2.0f)
          particle_speed = Speed of particles in the ball's particle trail.
<br><br>
<b>Default:</b><br>
Vector2f(-2.0f, -2.0f)<br><br>

<dl><dt><big>this();
</big></dt>
<dd>Construct a BallFactory, initializing factory data.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>DummyBallFactory</u>: pong.BallFactory;
</big></dt>
<dd>Factory used to produce dummy balls.<br><br>

</dd>
<dt><big>abstract class <u>Player</u>;
</big></dt>
<dd><u>Player</u> controlling a paddle.<br><br>

<dl><dt><big>void <u>score</u>(BallBody <i>ball_body</i>);
</big></dt>
<dd>Increase <u>score</u> of this player.<br><br>

</dd>
<dt><big>int <u>score</u>();
</big></dt>
<dd>Get <u>score</u> of this player.<br><br>

</dd>
<dt><big>string <u>name</u>();
</big></dt>
<dd>Get <u>name</u> of this player.<br><br>

</dd>
<dt><big>void <u>update</u>(Game <i>game</i>);
</big></dt>
<dd>Update the player state.
<br><br>
<b>Params:</b><br>
<table><tr><td>Game <i>game</i></td>
<td>Reference to the <i>game</i> that updates the player.</td></tr>
</table><br>

</dd>
<dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy this player<br><br>

</dd>
<dt><big>this(string <i>name</i>, Paddle <i>paddle</i>);
</big></dt>
<dd>Construct a player with given <i>name</i>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>ScoreScreen</u>;
</big></dt>
<dd>Displays score screen at the end of game.<br><br>

<dl><dt><big>this(GUIElement <i>parent</i>, Player <i>player_1</i>, Player <i>player_2</i>, real <i>time</i>);
</big></dt>
<dd>Construct a score screen.
<br><br>
<b>Params:</b><br>
<table><tr><td>GUIElement <i>parent</i></td>
<td>GUI element to attach the score screen to.</td></tr>
<tr><td>Player <i>player_1</i></td>
<td>First player of the game.</td></tr>
<tr><td>Player <i>player_2</i></td>
<td>Second player of the game.</td></tr>
<tr><td>real <i>time</i></td>
<td>Time the game took in seconds.</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big>class <u>BallSpawner</u>: scene.actor.Actor;
</big></dt>
<dd>Handles ball respawning and related effects.
<br><br>
When the spawner is created, it generates a set of directions the ball
 can be spawned at, in roughly the same direction (determined by specified spread)
 Then, during its lifetime, it displays the directions to the player
 (as rays), gives the player a bit of time and spawns the ball with one
 of generated directions.<br><br>

</dd>
<dt><big>class <u>BallSpawnerFactory</u>: scene.actor.ActorFactory!(BallSpawner).ActorFactory;
</big></dt>
<dd>Factory used to construct ball spawners.
<br><br>
<b>Params:</b><br>
<table><tr><td>time</td>
<td>Time to spawn the ball in.</td></tr>
</table><br>
<b>Default:</b><br>
5.0
          spread     = "Randomness" of the spawn directions.
                       Zero will result in only one definite direction,
                       1 will result in completely random direction
                       (except for horizontal directions that are
                       disallowed to prevent ball from getting stuck)
<br><br>
<b>Default:</b><br>
0.25
          ball_speed = Speed of the spawned ball.
<br><br>
<b>Default:</b><br>
200<br><br>

<dl><dt><big>this(real <i>start_time</i>);
</big></dt>
<dd>Construct a BallSpawnerFactory with specified start time.
<br><br>
<b>Params:</b><br>
<table><tr><td>real <i>start_time</i></td>
<td>Start time of the produced spawner.
                      The time when the ball will be spawned
                      is relative to this time.</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big>class <u>HUD</u>;
</big></dt>
<dd>In game <u>HUD</u>.<br><br>

<dl><dt><big>this(GUIElement <i>parent</i>, real <i>time_limit</i>);
</big></dt>
<dd>Constructs HUD with specified parameters.
<br><br>
<b>Params:</b><br>
<table><tr><td>GUIElement <i>parent</i></td>
<td>Parent GUI element for all the elements in the HUD.</td></tr>
<tr><td>real <i>time_limit</i></td>
<td>Maximum time the game will take.</td></tr>
</table><br>

</dd>
<dt><big>void <u>update</u>(real <i>time_left</i>, Player <i>player_1</i>, Player <i>player_2</i>);
</big></dt>
<dd>Update the HUD.
<br><br>
<b>Params:</b><br>
<table><tr><td>real <i>time_left</i></td>
<td>Time left until time limit runs out.</td></tr>
<tr><td>Player <i>player_1</i></td>
<td>First player of the game.</td></tr>
<tr><td>Player <i>player_2</i></td>
<td>Second player of the game.</td></tr>
</table><br>

</dd>
<dt><big>void <u>hide</u>();
</big></dt>
<dd>Hide the HUD.<br><br>

</dd>
<dt><big>void <u>show</u>();
</big></dt>
<dd>Show the HUD.<br><br>

</dd>
<dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy the HUD.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>GameGUI</u>;
</big></dt>
<dd>Class holding all GUI used by Game (HUD, etc.).<br><br>

<dl><dt><big>this(GUIElement <i>parent</i>, real <i>time_limit</i>);
</big></dt>
<dd>Construct a GameGUI with specified parameters.
<br><br>
<b>Params:</b><br>
<table><tr><td>GUIElement <i>parent</i></td>
<td>GUI element to attach all game GUI elements to.</td></tr>
<tr><td>real <i>time_limit</i></td>
<td>Time limit of the game.</td></tr>
</table><br>

</dd>
<dt><big>void <u>show_hud</u>();
</big></dt>
<dd>Show the HUD.<br><br>

</dd>
<dt><big>void <u>show_scores</u>(real <i>time_total</i>, Player <i>player_1</i>, Player <i>player_2</i>);
</big></dt>
<dd>Show score screen.
<br><br>
Should only be called at the end of game.
 Hides the HUD. When the score screen expires,
 score_expired is emitted.

<br><br>
<b>Params:</b><br>
<table><tr><td>real <i>time_total</i></td>
<td>Total time the game took, in game time.</td></tr>
<tr><td>Player <i>player_1</i></td>
<td>First player of the game.</td></tr>
<tr><td>Player <i>player_2</i></td>
<td>Second player of the game.</td></tr>
</table><br>

</dd>
<dt><big>void <u>update</u>(real <i>time_left</i>, Player <i>player_1</i>, Player <i>player_2</i>);
</big></dt>
<dd>Update the game GUI.
<br><br>
<b>Params:</b><br>
<table><tr><td>real <i>time_left</i></td>
<td>Time left in the game, in game time.</td></tr>
<tr><td>Player <i>player_1</i></td>
<td>First player of the game.</td></tr>
<tr><td>Player <i>player_2</i></td>
<td>Second player of the game.</td></tr>
</table><br>

</dd>
<dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy the game GUI.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>GameContainer</u>;
</big></dt>
<dd>Container managing dependencies and construction of Game.<br><br>

<dl><dt><big>Game <u>produce</u>(Platform <i>platform</i>, Monitor <i>monitor</i>, GUIElement <i>gui_parent</i>);
</big></dt>
<dd>Produce a Game and return a reference to it.
<br><br>
<b>Params:</b><br>
<table><tr><td>Platform <i>platform</i></td>
<td>Platform to use for user input.</td></tr>
<tr><td>Monitor <i>monitor</i></td>
<td>Monitor to <i>monitor</i> game subsystems.</td></tr>
<tr><td>GUIElement <i>gui_parent</i></td>
<td>Parent for all GUI elements used by the game.</td></tr>
</table><br>

</dd>
<dt><big>void <u>destroy</u>();
</big></dt>
<dd>Destroy the contained Game.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Credits</u>;
</big></dt>
<dd><u>Credits</u> screen.<br><br>

<dl><dt><big>this(GUIElement <i>parent</i>);
</big></dt>
<dd>Construct a Credits screen.
<br><br>
<b>Params:</b><br>
<table><tr><td>GUIElement <i>parent</i></td>
<td>GUI element to attach the credits screen to.</td></tr>
</table><br>

</dd>
<dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy this credits screen.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>PongGUI</u>;
</big></dt>
<dd>Class holding all GUI used by Pong (main menu, etc.).<br><br>

<dl><dt><big>this(GUIElement <i>parent</i>);
</big></dt>
<dd>Construct PongGUI with specified parameters.
<br><br>
<b>Params:</b><br>
<table><tr><td>GUIElement <i>parent</i></td>
<td>GUI element to use as <i>parent</i> for all pong GUI elements.</td></tr>
</table><br>

</dd>
<dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy the PongGUI.<br><br>

</dd>
<dt><big>Monitor <u>monitor</u>();
</big></dt>
<dd>Get the <u>monitor</u> widget.<br><br>

</dd>
<dt><big>void <u>monitor_toggle</u>();
</big></dt>
<dd>Toggle monitor display.<br><br>

</dd>
<dt><big>void <u>menu_show</u>();
</big></dt>
<dd>Show main menu.<br><br>

</dd>
<dt><big>void <u>menu_hide</u>();
</big></dt>
<dd>Hide main menu.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/1.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
