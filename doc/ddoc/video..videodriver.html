<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>video.videodriver</title>
        </head><body>
        <h1>video.videodriver</h1>
        <!-- Generated by Ddoc from video//videodriver.d -->
<br><br>
<dl><dt><big>abstract class <u>VideoDriver</u>: monitor.monitorable.Monitorable;
</big></dt>
<dd>Handles all drawing functionality.<br><br>

<dl><dt><big>protected FontManager <u>font_manager_</u>;
</big></dt>
<dd>FontManager used to work with fonts.<br><br>

</dd>
<dt><big>this(FontManager <i>font_manager</i>);
</big></dt>
<dd>Construct a VideoDriver.<br><br>

</dd>
<dt><big>void <u>die</u>();
</big></dt>
<dd>Destroy the VideoDriver.<br><br>

</dd>
<dt><big>void <u>set_video_mode</u>(uint <i>width</i>, uint <i>height</i>, ColorFormat <i>format</i>, bool <i>fullscreen</i>);
</big></dt>
<dd>Sets video mode.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>width</i></td>
<td>Screen width to set in pixels;</td></tr>
<tr><td>uint <i>height</i></td>
<td>Screen height to set in pixels;</td></tr>
<tr><td>ColorFormat <i>format</i></td>
<td>Color format to use for screen.</td></tr>
<tr><td>bool <i>fullscreen</i></td>
<td>If <b>true</b>, use <i>fullscreen</i>, otherwise windowed.</td></tr>
</table><br>
<b>Throws:</b><br>
Exception on failure.<br><br>

</dd>
<dt><big>void <u>start_frame</u>();
</big></dt>
<dd>Start drawing a frame. Must be called before any drawing calls.<br><br>

</dd>
<dt><big>void <u>end_frame</u>();
</big></dt>
<dd>Finish drawing a frame.<br><br>

</dd>
<dt><big>void <u>scissor</u>(ref Rectanglei <i>scissor_area</i>);
</big></dt>
<dd>Enable <u>scissor</u> test using specified rectangle as <u>scissor</u> area.
<br><br>
Until <u>scissor</u> test is disabled, only specified area of the screen
 will be drawn to. This can be used e.g. for 2D clipping of GUI.

<br><br>
<b>Params:</b><br>
<table><tr><td>Rectanglei <i>scissor_area</i></td>
<td>Scissor area in screen coordinates.</td></tr>
</table><br>

</dd>
<dt><big>void <u>disable_scissor</u>();
</big></dt>
<dd>Disable scissor test.<br><br>

</dd>
<dt><big>void <u>draw_line</u>(Vector2f <i>v1</i>, Vector2f <i>v2</i>, Color <i>c1</i>, Color <i>c2</i>);
</big></dt>
<dd>Draw a line between specified points, with specified colors.
<br><br>
Colors are interpolated from start to end of the line.
 If the points specified are identical, drawn result is undefined.

<br><br>
<b>Params:</b><br>
<table><tr><td>Vector2f <i>v1</i></td>
<td>Start point of the line.</td></tr>
<tr><td>Vector2f <i>v2</i></td>
<td>End point of the line.</td></tr>
<tr><td>Color <i>c1</i></td>
<td>Color at the start point.</td></tr>
<tr><td>Color <i>c2</i></td>
<td>Color at the end point.</td></tr>
</table><br>

</dd>
<dt><big>void <u>draw_line_strip</u>(Vector2f[] <i>v</i>, Color <i>c</i>);
</big></dt>
<dd>Draw a line strip through specified points with specified color.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector2f[] <i>v</i></td>
<td>Vertices of the strip.</td></tr>
<tr><td>Color <i>c</i></td>
<td>Color of the strip.</td></tr>
</table><br>

</dd>
<dt><big>void <u>draw_circle</u>(Vector2f <i>center</i>, float <i>radius</i>, Color <i>color</i> = Color(cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u), uint <i>vertex_count</i> = 32);
</big></dt>
<dd>Draw a circle with specified <i>center</i>, <i>radius</i>, <i>color</i> and number of vertices.<br><br>

</dd>
<dt><big>void <u>draw_rectangle</u>(Vector2f <i>min</i>, Vector2f <i>max</i>, Color <i>color</i> = Color(cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u));
</big></dt>
<dd>Draw a rectangle with specified extents and <i>color</i>.<br><br>

</dd>
<dt><big>void <u>draw_filled_rectangle</u>(Vector2f <i>min</i>, Vector2f <i>max</i>, Color <i>color</i> = Color(cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u));
</big></dt>
<dd>Draw a filled rectangle with specified extents and <i>color</i>.<br><br>

</dd>
<dt><big>void <u>draw_texture</u>(Vector2i <i>position</i>, ref Texture <i>texture</i>);
</big></dt>
<dd>Draw a <i>texture</i> at given <i>position</i>.<br><br>

</dd>
<dt><big>void <u>draw_text</u>(Vector2i <i>position</i>, string <i>text</i>, Color <i>color</i> = Color(cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u,cast(ubyte)255u));
</big></dt>
<dd>Draw a string of <i>text</i> at given <i>position</i>.<br><br>

</dd>
<dt><big>Vector2u <u>text_size</u>(string <i>text</i>);
</big></dt>
<dd>Return the size a <i>text</i> string would have if it was drawn.<br><br>

</dd>
<dt><big>void <u>line_aa</u>(bool <i>aa</i>);
</big></dt>
<dd>Enable/disable line antialiasing.<br><br>

</dd>
<dt><big>void <u>line_width</u>(float <i>width</i>);
</big></dt>
<dd>Set line <i>width</i>.<br><br>

</dd>
<dt><big>void <u>font</u>(string <i>font_name</i>);
</big></dt>
<dd>Set <u>font</u> to draw text with. If <i>font_name</i> is "default", default <u>font</u> will be used.<br><br>

</dd>
<dt><big>void <u>font_size</u>(uint <i>size</i>);
</big></dt>
<dd>Set font <i>size</i> to draw text with.<br><br>

</dd>
<dt><big>void <u>zoom</u>(real <u>zoom</u>);
</big></dt>
<dd>Set view <u>zoom</u>.<br><br>

</dd>
<dt><big>real <u>zoom</u>();
</big></dt>
<dd>Return view <u>zoom</u>.<br><br>

</dd>
<dt><big>void <u>view_offset</u>(Vector2d <i>offset</i>);
</big></dt>
<dd>Set view <i>offset</i>.<br><br>

</dd>
<dt><big>Vector2d <u>view_offset</u>();
</big></dt>
<dd>Return view offset.<br><br>

</dd>
<dt><big>uint <u>screen_width</u>();
</big></dt>
<dd>Return screen width.<br><br>

</dd>
<dt><big>uint <u>screen_height</u>();
</big></dt>
<dd>Return screen height.<br><br>

</dd>
<dt><big>uint <u>max_texture_size</u>(ColorFormat <i>format</i>);
</big></dt>
<dd>Return maximum square texture size supported with given color <i>format</i>.<br><br>

</dd>
<dt><big>Texture <u>create_texture</u>(ref Image <i>image</i>, bool <i>force_page</i> = false);
</big></dt>
<dd>Create a texture from given <i>image</i>. Optionally force the texture to have its own texture page.<br><br>

</dd>
<dt><big>void <u>delete_texture</u>(Texture <i>texture</i>);
</big></dt>
<dd>Delete given <i>texture</i>.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/1.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
