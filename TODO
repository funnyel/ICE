08:
    Push to GitHub.
    
19:
    Then: simple binary archive, both 32-bit and 64-bit if possible.
    At least Linux, but also Windows if possible. Maybe even Mac if we can find
    someone with one.
    And detailed installation instructions both from source and binary archive
    on wiki, and in an article (maybe a script to do the installation).
    Maybe also in README (at least a link)
09:
    Write detailed tutorials on installing from source and test installing
    according to these tutorials on other PC's with Linux as well as in VirtualBox 
    pe
    with various distros

    Also, create a Xonotic-like package with 32bit and 64bit binaries
    and all or most dependencies (not sure about SDL, FreeType) - 
    dependencies not present should be specified so users know what they need
11:
    Get the thing to compile on Windows (if it doesn't work already).

    Probably use Cygwin, it might be easier that way.

    If SDL is a problem, create SFML Platform implementation.
    Platform implementations to compile should be specified at compile time
    to prevent requiring all dependencies.

    Update README, wiki, tuts, etc. with Windows installation instructions.
12:
    Write these TODOs to an issue tracker of some kind.

--D2
4:
    Consider D2 (at this point it might be mature enough :p)
    We'll need to port CDC first, look if there's a new CDC, if not,
    port it, test with some small test project

    Alternatively, consider rewriting CDC in Python (3.x). That would allow us
    to split it into multiple files without complicated compiler commands.
10:
    Write developer docs with stuff like how to get started hacking
    the engine, see Wesnoth, OGRE, other projects that do this well.
    E.g.: how to read a file. how to create a widget doing something.
    how to create a monitor. etc.
5:
    Profile and optimize.
11:
    Drawing in separate thread:
    Both in GUI and in SceneManager, this thread works ONLY on const actors/elements,
    just reading, never writing.
    This should not cause problems even if it draws stuff during a physics update
    (would draw some objects in e.g. physics update 1555, and some in 1556, not
     a big deal) In the physics/game state thread, time not spent updating 
    would be spent sleeping (first just use an infinite loop as a placeholder)

    Only thing to keep an eye on: drawing thread must never read
    data that is invalid at the moment, e.g. during some kind of update.
    Might still need per-object locks for that.
    Only acquired by non-const methods, though. Maybe D2 has something
    like synchronized in D1 for that.

    THis should completely remove time aliasing.
5:
    Memory usage: consider more
    advanced recording and storage for GraphData
    (monitor running in background, not measuring all the time, 
     gradual data loss, gzipping in memory, dumping to file)
    Also consider making GraphData time independent, supplying time
    through methods.

5:
    Each file should have a documentation header, not just documentation
    for classes/functions.
05:
    Weak singleton class handling time, updating actormanager and perhaps other
    stuff. Pass this class when updating actors, instead of time_step, game_time.
    This class will also allow timed delegates,
    both delayed in real time and in game time. Use this in BallSpawner, ScoreScreen.
    Might allow timers, which, when expired, call a delegate, as well as timed signals,
    and signals that are fired at the beginning of the next frame.
    However, that might require globally accessible singletons (no testability) 
    -only do stuff that needs no singletons
10: 
    Background colors for GUI elements (nothing more, for now - just rects with color)
11:                                    
    Options start: player names (also, whether the player is AI or human-
    so we can have AI/AI, AI/human, human/human)
    Character count should be limited to fit to score statictexts.
    Also time/score limit.

    Also graphics settings (enable/disable certain particle systems, maybe more)

    Screen size change

    Video driver settings too (draw mode, line aa)

    After that, keyboard settings for each player
12:
    Settings from ini files, also paddle, ball, wall properties
    (possibility to add more walls from INI files, but hardcoded two paddles)
    and paddle, ball graphics objects serialization (including line trail
    particle system, maybe others of coded)
    Among other things, time speed and update period of actormanager should
    be in INI files.

    GUI should also be serializable to/from INI
    There should be default set of values (in INI), e.g. for buttons in general,
    and every button could be customized with INI code that only mentions
    differences.

    Both GUI layout files and GUI skins/themes (just border widths/colors for now)

    FontManager settings like FontAA and FastGlyphs should be set through INI
    (also the default font?, etc.)

    Alternatively, use YAML (or even WML?) from start.


    Newest ideas:
    We need to separate GUI content (element dimensions, text, etc)
                    and GUI presentation (border color, font size, etc.)

    Handle these in separate files.

    It would help to have a GUIStyle class ahndling all presentation parameters
    and pass that to GUIElement factories.
    Maybe even move dimensions to style, but that would require each element
    to have a name (or a CSS-like class/id?) and get its data according to that.

    Actually, the CSS-like class/id might be the best idea.

    Also, it would be good to have an option to reset, reload the GUI at run time.
    That'd help modders changing GUI style.
13:
    Adjust graphics and GUI for various resolutions - particularly 640*480
4:
    Whether or now we're at D2, move to Derelict2 (if we haven't moved to D2,
    we can only do this if Derelict2 is not D2 only.)
    Replace current use of GL_EXT_framebuffer_object with GL_ARB_framebuffer_object.
15:
    Options: ball speed.
14:
    AI difficulty settings

    Optional(user options) smarter AI that takes note of ray hints from BallSpawner
    (only if those rays intersect with the goal - ignore if they're intersecting
     the walls to prevent extra stupidity)
26: 
    Sounds
27: 
    Release #2, And announce it this time!

AFTER RELEASE #2:
17:
    Multiplayer, with single PC and over a network (test with two computers)
17: 
    Effects:
    when changing the gui, (e.g. moving from menu to pong, or between dialogs), 
    draw an animation with gui leaving the screen                    
    to the left. we can do this with a guioffset member in gui root
    or, better, by using a separate GUI element (under root) as root for all
    game GUI. That way Monitor wouldn't be affected.

    Concept: 
    User clicks Credits.
    Credits screen is created, left of the viewport, menu is not hidden yet.
    GUI moves left, moving main menu out of the view.
    mein menu is hidden.
    When user clicks the close button in credits screen, opposite happens.

    Alternatively, all the GUI elements could always be there, with
    the GUI simply moving from one to the next, i.e. no hiding.

    We need some class to manage this effect, that class being the GUI element
    used as root of the game GUI.

    We would simply use some method to add() GUI elements to this class
    that would be managed this way, and implementation of this class
    would decide on the effect to change them (e.g. a basic effect would be
    to have all the "screens" in a horizontal row, with always only one per screen.
    Alternative implementation could pack them tightly together, so the current
    "screen" is centered but you can see adjacent ones. Another alternative 
    implementatio could be some zooming effects, and so on, and so on.)
16:
    Draw cursor
18:
    main menu could have an ai-ai game playing in the background
20:
    Multiple (two, and maybe option to generate) color schemes
    (game, not GUI, colors)
25:
    Consider abstracting
    GLTexturePage to TexturePage and moving as much code as possile to VideoDriver,
    in such a way that VideoDriver, not GLVideoDriver, manages pages,
    using GLVideoDriver overriden methods. I.e. algorithms in VideoDriver,
    specific stuff in GLVideoDriver.
25:
    Simple logging. (basically just a wrapper around std.stdio
    with a few extra features maybe, but no console or in-game log display yet.
    Look at Wesnoth, Xonotic, other FOSS games and how they handle logging.
    Also articles on FlipCode, GameDev, DevMaster, GPWiki and such.
    Remember to make it simple.)

    Note that we'll need a flush (and writeln?) function for the log file,
    so it is "opened" permanently and "flushed" after every write
18:
    If both UPS and FPS is over some value, sleep from time to time
    to free up CPU. This should be enabled/disabled by a debug button somewhere
23:
    Profiling: 
    Manual time measurement - at least get total time and VideoDriver methods' time,
    but might want something more fine grained.
    If slow, move it to separate build. 

    Also, we could view this stuff in graph monitors.

    Special build for OpenGL benchmarking with GLFinish between frames
    or maybe even between parts of frames. Also a benchmark option
    to decrease viewport size to something like 4 * 3, eliminating fragment
    processing.
4:
    Hierarchical resource manager:
    (Current font code does not fit this, as there's no way to load/unload
     fonts from user side. Might change that with simple VideoDriver load_font,
     unload_font methods or with font handles working like texture handles.
     (with a default font handle of course))

    Hierarchical idea is very elegant for levels, mods, whatever:

    Idea seen here:

How I do it is to have roughly these classes:

Representation - e.g. Texture

Resource Locator (not always necessary)

Resource Factory (sometimes just a constructor in the Representation)

Hierarchical Resource Cache


The key is the last one. I have multiple caches, 
which interact in a hierarchical manner. 
One is created in main, and it is used to 
load the non-game resources (menu resources, music, etc). 
Others are created for each level.

The cache for the first level uses the "global" one in main() as a parent. 
When resources are loaded, the parent is consulted, as well as the local cache,
before delegating to the factory to build a new resources.

Between levels, the old cache is used as the parent of the new cache. 
This means that data that persists between level 
(in your example, player mesh and common enemies)
will pull them from the previous level. Once the new level is loaded, 
the set of resources that are now unused are freed by disposing the previous cache. 
This is all implicit, there is no need to specify whether a resource is going to 
be common between levels.

Downsides of this approach:

During level transitions you have all the resources for two levels in memory, 
even if lots for the previous level aren't going to be re-used. 
This isn't a problem for me because the games I write are small 2D games 
with relatively small resource usage.

It is fairly static, every resource must be touched at level load to ensure 
it stays resident and isn't flushed.

It isn't a true cache, there is no replacement policy. 
If a resource is used once in the level, even temporarily, 
it will remain memory resident for the entire l
15:
    GLVideoDriver Debug tool (maybe belonging to monitors):
        -Set draw mode.
        -Replace all textures with a 2x2 placeholder.
        -Force line AA off
        -Reload all shaders (can be changed on runtime this way)
        -Reload all textures
             Would need management shaders as textures are now loaded from 
             mages passed by the user, but would be extremely useful for modders.
             Alternatively, user code managing textures might do this, in a separate
             debug tool. Probably better that way.
        -etc.

7:
    Unary - for math expressions so we can avoid currently used hack in substitute()
7:
    Shaders should be available to the user, passed to draw functions 
    (with defaults) - this might require a shader spec format 
6:
  FPS benchmark
6:
  Save screenshots in a separate thread.
6:
    Logic change: when ball collides with anything, emit a signal
    with its body of the other collider and check that for
    collision with goals, etc. 
    This will make more sense in Arkanoid and support more balls.
14:
    Unittest overhaul all over the code.
    Look at where we can put unittests and do it.

    Unittests for actors, bodies etc.

    Then we can test them with simple dummy manager classes,
    or, if needed, subclassed real managers with most methods as dummies

    also try to unittest subsystems, maybe using subclassed semi-dummy
    implementations - can't do this for platform/videodriver,
    others should work.

    Also look for where we can put unittests
24:
    Alongside mouse_move and mouse_key, consider more advanced
    mouse_click (triggered by quick succeeding press and release),
    and mouse_drag
    these would be detected by platfom and sent to e.g GUI

    Alternatively, they could be detected by a custom class working
    similarly to GUIMouseControllable and sent through signals
    to whatever code needs them.
14:
    Postprocess shaders:
    Draw scene to texture through FBO first, then put that on a quad taking
    up the whole screen. Apply post process shaders to that.
    Effects such as nuke in RA2 could work that way.
    We could also chain effects by drawing that to FBO, running through another 
    shader, and so on (the only way to apply multiple shaders without
    having hardcoded number of shaders called from a main function in a shader)
    - this might be slow, but maybe not too slow. Mainly taxing fragment shaders.
14:
    SpatialManager:
    Write code required for culling (special iterator), and use in culling.

    As drawing volumes could need to change (particle systems),
    so we might have a special function supplying old volume at update/remove.
    Write that as a future TODO. 
15:
    Command line parser: implement positional arguments, subparsers (e.g. git commit),
    equivalents of choices= and required= paramters of argparse in Python
    (if needed)
15:
    Consider tree-based math parser. Advantage is:
    GUI elements can keep the tree and just change the vaues of substitution,
    tree can be evaluated w/o being regenerated. If this is not needed, move it to 
    optimization TODOs
    This parser would use the current code to convert to postfix notation and generate
    the tree from that.

    Better idea could be a MathExpression class, maybe even better a struct:
    would create the tree on construction, would be immutable,
    would check the string on construction, also make GUI parameters
    more explicit, would support construction from existing MathExpressions.
    Also, would explicitly require a dictionary containing all needed tokens for
    evaluation.

    Most importantly would allow significant implementation changes
    on the background.
17:
    Write a script using OProfile to get CodeAnalyst- like stats.
    (for now, just stats per process, library, function, not per line)
    Maybe even a GUI (best with our own GUI, but QT/Vala/PyGTK would be good too.).
    Even if there is a GUI, though, it should be only built as a frontend for the script.
    The script might be in Python 3 or in D.
    
    It should support a simple interface to select the binary to run, 
    use sudo to get password from the user (through gksudo?),
    offer builtin profiles (what is measured and how much per second),
    as well as support for custom profiles.
    Could also demangle D function (and class?) names.
8:
    Subset of HTML tags for text drawing (just support <br> for now),
    will need a parser (fast!) and e.g. StaticText will need to use
    a class/module that will split the html text into lines.

    Alternatively, something like txt2tags or markdown. Look for
    info about both. E.g. in txt2tags two newlines in a row would
    separate paragraphs, resulting in a gap between lines.

    lightweight markup language would be good for source readability,
    html e.g. for tables (although those might work in a lml too -
    especially if we do them our own way
24:
    Advanced memory monitor: per-type usage graphs, 
    number of allocations per  e.g. second (graph),
    also a graph showing each allocation as a box
    with size depending on size of allocated memory (advanced, but could help)
4:
    Particle system overhaul. Every particle should have its own color,
    etc; and whole thing should have a better structure.
    Also, LineTrail might not need to be derived from LineEmitter
    (no need for line length, angle variation, emit velocity,
     so why is it derived?)
    and particleemitter might be merged with particlesystem

    One good idea might be to base the new particle system code
    on templates, template mixins and string mixins.
    Also look at policy based design.

    Probably, each particle should contain all the data it needs to draw
    itself and contain all drawing, updating logic.
    This way, most particle systems would only need to be template classes
    with the particle class as the template parameter.
5:
    Find some use for multithreading, e.g. asynchronous drawing
    or physics, or maybe OpenMP style (or just 2-4 threads)
    for collision detection (not penetration resolution or response,
    at least for now)
10:
    Test mod directories with a simple Pong "mod" that replaces shaders
    and/or fonts (say, with negative or black/white colors or something)
8:
    timer calling a given function at expiration,
    and some kind of singleton or module to update these timers to
    check for expiration - that update would be called by whole
    pong, not game. maybe later it could be updated from separate thread, but probably
    not.
    Would be used like e.g. time.delayed_call(function(args), delay);
11:
    A debug (ini, console and/or debug GUI controlled) option to draw wireframe.
    Also might want pure white wireframe option (with a custom shader)
    Would be a good feature for GLMonitor.
12:
    Consider (or not) a hierarchical ActorManager. Physics objects would also
    need some hierarchy (or not - will see)
13:
    Voxels?
    Look at any existing file formats, but probably need our own.
    8-bit or 16-bit normals, 16-bit or 32-bit color (with alpha),
    zlib or lzma compression, PNG-like.
    Look at PolyVox for 3D model to voxel conversion, maybe some other tools.
    Also write an import tool for RA2/TS voxels.
    For drawing, we need to use point sprites as plain points are deprecated.
    Also look up marching cubes algorithm.
14:
    Could also look at the source of the Diamond memory debugger and
    use the ideas there to measure memory usage
12:
    Shaders should be an optional argument to draw_x. If no shader is passed,
    default for fonts, lines, textures is used.
    Just as images are passed to create textures, shader spec (ini) files
    should be passed to create_shader. Both images and shader spec
    files should be managed outside videodriver.
    shader spec file should contain a spec for every videodriver supported.
    GLSL shaders should be stored in whatever/shaders/glsl,
    since those will be managed on the videodriver implementation side.
    Actually, not necessarily spec per videodriver, but e.g. GLSL spec,
    fixed function spec, Cg spec etc. 
    E.g. any GLSL capable videodriver could use the GLSL spec.
13:
    resource manager, use that for font, shader, ini 
24:
    Selecting GUI elements with keyboard:
    only certain element types can be selected (e.g. button)
    (an element has a bool selectable() method):
    Arrows are used to select elements, maybe later tabs could
    select groups (would be more complicated) - if selected,
    Enter and/or some other keys could be used to control the element.
30?:
    Rotation (of 2D actors) - Velocity should then be in object space,
    not world space. Immediate use would be rotating balls.
    Also, the same paddle could be used up and down, just rotated.

    for 3D rotation, we might want to use a Rotation struct with opague
    implementation and stable interface so we can replace internals
    with matrices, quaternions, euler angles or whatever (of course, 2D
    rotation doesn't need this- just use a float for that)
35:
    Logging messages (e.g. initializing GL, etc.)- not necessarily a logging
    system yet
33?:
    Might be left for later (e.g. before map editor):
    GUI: more advanced, moving/resizing (can be enabled/disabled),
    element names and getting elements by name,
    serialization (Root should have save_layout, load_layout methods),
    maybe a simple editor

    GUI could have a complex border composed of
    8 sections (top, down... + corners), using > 1.0 texcoords
    to repeat textures for resizing/support of varying sizes. 
    (once textures are done)
34:
    Drawable abstraction. 
    Can be a line mesh/mesh group, sprite (with many textures),
    3d model (with many meshes)
    Alternatively can be a single class composed of any number of 
    lines/sprites/meshes

    Serialization should go through a standardized interface so
    we can change file format (INI, XML, binary, compressed...)

    First just support lines, then add sprites, and _maybe_ add 3d
    stuff later.
35:
    Translatable text, and a simple string format with 
    bold/italic/underlined and text colors.
    That would be passed to the code that draws fonts.
    Might be in a single class. Should have a method to
    return the string without tags. 
    Maybe use simple CSS-like styles for the text, etc.
    Formatting should probably be left for later, but translatable text
    ASAP. Needs resource management first, though.

    We could also use shaders to invert text colors if wanted, etc.
37:
    OpenGL driver profiling:
    Might consider an Image method to_bgra() and using GL_BGRA format.
    Also profile glTexSubImage calls, consider replacing that with pbuffers
    or: combine textures to pages on cpu; when drawing, use glTexImage to
    move to GPU; when again adding textures to a page, use
    glGetTexImage to get it back to cpu side, repeat.
    Also profile all the other GL stuff, like texture drawing, shaders.
    Might consider the NVidia profiling driver for this.
    Also consider various page sizes - something like 512x512
    might have better cache performance than 4096x4096.
38: 
    Culling at videodriver level
38:
    Remapping should be done with shaders using colors with alpha 0 
    as remap colors. Only RGBA 0,0,0,0 should be a valid totally transparent color.
    R 1-255 should be used as remap index (255 remaps colors at most)
    G 0-255 (256 values) should be used as lightness of the remap color,
    and G 1-255 (255 values) as its alpha colors 
    (0 is fully transparent and should be RGBA 0,0,0,0).
39:
    Custom exception class/es, should add the message to the log.
    Better: Java-style descriptive exceptions, maybe derived from 
    a parent class handling logging.
36: 
    Console        
15:
    FormattedText class/struct that could contain various
    formatting options like line width, line spacing, 
    left/right justified/centered, in future maybe even various 
    font colors, sizes, etc.
    Would need its own viewer GUI element. (actually, just a class to break
    it up into lines  GUIStaticText and any other future text widgets could
    draw it OK)
    Maybe just use txt2tags/other lightweight markup language 
    with simple CSS or CSS-like something.
    Or a subset of HTML tags (there should be good tutorials for that and it
    would be familiar to users)

    Especially, use of <br> or some other explicit line break would be good
    instead of using \n as explicit newline.
40?:
    Particle system overhaul - turn ParticleEmitter into PointEmitter,
    add something like PolygonEmitter (or at least RectangleEmitter, LineEmitter),
    and in general, make particles more flexible.
   



Announcing:

D mailing lists
GPWiki,
GameDev.net,
OpenGameArt,
Ubuntu Forums (when packaged... or before?),
libsdl.org,
Freshmeat,
Ohloh


Packaging:

OpenSUSE Build Service?

licensing:
derelict links to sdl dynamically. so we don't need to use lgpl
we need to give credit to freetype based on its license (if used).
see freetype.org


Monitor:
1:
    TexturePages info: show free/used space with slight red/blue tints,
    show borders of the texture, and borders of nodes.
    Also might be useful to have buttons to show only node borders/
    texture page/free-used
    Show whether the texture is resident, too.
2:
    Show stats about overhead of all textures in the driver,
    each page and its packer
3:  
    Pages: use glGetTexLevelParameteriv with some argument to get
    size the page takes up in the video memory.
4:
    PhysicsMonitor ideas:
    1:need listbox: snapshot of all collisions in a certain frame
    2:need listbox: detailed look on an object, i.e. select object and see all its parameters

Optimizations:
1:
    Allocator alloc/dealloc recording could be done using
    an associative array with typeid as index instead of a string.
    Typeid would be converted to string when writing to output.
2?:
    Textures could be made smaller by using Vector2s for size
    instead of Vector2u. This has proven to speed up font drawing
    by ~15%. However, would probably result in a bit uglier code
    and need for asserts for too large textures/pages.)
    (would require to pass textures/glyphs by value in font drawing code)

    Also, GLTextures could store texcoords as unnormalized shorts, but
    that would probably be overkill
3?: 
    Alpha testing could be used in combination with blending. I.e.
    a fragment with 0 alpha would automatically be discarded.
    This would break our remap plans, though.
    However, if we culd do this in shader (need to learn how to discard
    a fragment in shader), everything would work right.
4?:
    If color interpolation is a problem, we can create a ColorInterpolator class,
    which is basically a lookup table constructed with color a, color b, 
    and an integer specifying number of colors in the table. Any call to interpolate()
    method of that class would then return the closest table value for
    float given as ann interpolation value.
5?
    fast sqrt in math.math using a lookup table
    like, if the input is between 0-1, look it up in table #1 with 100 (float)
    results for 0.00, ... 0.99
    if 1-10, table #2 with 90 results for 1.0, ... 9.9
    etc for 100, 1000
    if more, use usual sqrtf

    alternatively: look at how opensource 3D engines do sqrt and google for other 
    methods, maybe try using carmacks' reciprocal sqrt 
    (1/sqrt, so 1/reciprocal is sqrt)
6?:
    If drawing text is too slow, we can cache glyph offsets for strings
    somewhere in videodriver (or a member class/struct of videodriver)
    We can search for cached strings quickly using simple bucket sort/search.
7: 
    PNG:
    Decoding time is 45% zlib decoding, 45% unfiltering and 10% array copying.

    We could optimize PNG unfiltering with pure asm paeth predictor,
    SSE, (MMX might be good as well, as we're dividing ubytes and MMX is
    useful for integer ops) even multithreading.

    Also we could try to reduce copying.

    Encoding: Almost all time is zlib.

    We could fix that by rolling our own zlib clone, maybe using SSE and/or 
    multithreading.
8:
    If GLVideoDriver vertex cache is too slow, we could use mapped VBO
    in the GLVertexBuffer instead of a vector.
    Alternatively, we could double buffer
    (draw vbo1, copy to vbo2 at frame 1, draw vbo2, copy to vbo1 at frame 2, repeat),
    or even combine mapped VBO with double buffering.
    This could significantly improve performance at high loads where
    OpenGL can take as much as 40% time stalling buffer data uploads.
9:
    RGBA4 (converted from RGBA8 in VideoDriver implementation) 
    could be a switch for low-memory systems
GUI:
1:
    Progress bars should be a simple animation with frame depending
    on progress of something. This way we can have various 
    loading bars, unit construction progress C&C style, etc.
2:
    once loading GUI from files, CSS-like style code (subset),
    and look at YAGE GUI
GL1:
1:
    Remapping equivalent to shader based remapping 
    (i.e. using colors with alpha 0 as remap) can be done without shaders
    using GL_ARB_imaging with color tables, or with core OpenGL 1.x pixel
    mapping. OpenGL SuperBible explains how to do this.
Maybe:
1:
    Paddle acceleration
4:
    Consider writing a tool like 3DtoSprite seen at 
    http://irrlicht.sourceforge.net/phpBB2/viewtopic.php?t=25397
    Use OpenGL to render frames of a sprite, based on some settings
    (e.g. resolution, xyz model offset, camera angle, number of angles
     the object can face, ambient/directional/local lights, maybe
     shaders to change the colors, etc.)
    This would need 3D animations (maybe bone or frame-to-frame interpolations too),
    but it could be done with simple, brute force code as it would not be
    realtime. Try to do this through VideoDriver
    so that any future non-OpenGL backends can be used.
    We don't need perspective for this; ortho is OK.
    Accumulation buffer (or rather some equivalent GL3 method) 
    could be used for high quality AA, and per pixel lighting
    could be used as well. In future, even normals used for 3D lighting could be 
    drawn.
13:
    (Arkanoid) High scores
14:
    This might not be needed if we draw stuff in the right order:
    A draw order/layer argument passed to videodriver draw methods, 
    should be a real value (so in isometric games we can base it on object height) 
    - every frame, a bucket sort or something might be used to sort objects to depth 
    groups.
15:
    Proper time_string function supporting any time format,
    like /usr/bin/time
16:
    If multitextures will be supported in future, their data should
    be stored in pairs/triplets/quadruplets/etc of pages.
    We'd only have to change GLTexture, not Texture:
    GLTexture would contain indices of the pages.
    A special createtexture method would be needed.
    (taking multiple images).
15:
    (Arkanoid)Save games (ini?)
22: 
    Try AI and/or file loading in a separate thread
Bugs:
1:
    We're not deleting OpenGL vertex buffer names because of what seems to
    be a driver bug. This still might be a bug in our code. As we only
    use a few buffers during run time and deallocate them, this is unlikely
    to cause problems, but should be fixed if possible.
