Desingletonify FontManager:

VideoDriverContainer, font unloading/reloading
Testing it





17:
    Desingletonify VideoDriver, FontManager and manage them in
    a VideoDriverContainer.
    If possible, we could have a single instance of FontManager used
    even if VideoDriver is replaced. However, as FontManager
    loads fonts as textures to VideoDriver, it should have
    a method to reload these textures to videodriver again.
    Implement this, the code for loading fontmanager textures again,
    and a unittest to prove it works (slow unittest due to file I/O,
    but, after all, unittests can be disabled in release build)

    Also, we might have a debug button to test reconstruction of VideoDriver,
    to see if e.g. the GUI stays the same.
    Actually, we can do that with a "change video mode" setting
    in an Options screen.
    Of course, we want to do stuff like changing video mode
    without replacing video driver later, but now, it's an excellent way of testing
    this.


    Note that a reset of VideoDriver will also require to change
    the VideoDriver of Monitor,
    so we'll need methods for that.
17:
    Desingletonify Platform, if at all possible.
    Also test destroying/reconstructing platform.
    Of course, platform destruction will require VideoDriver
    destruction, so they probably should be managed by the same container
    (PlatformContainer manages VideoDriverContainer?)
17:
    Unittests where obviously easy.
17:
    Coarse collision detection (SpatialManager)
    Maybe make SpatialManager general enough so we can use the same class
    (not same instance, probably) for both coarse collision detection and culling

    For now, just implement a grid, not quadtree. Might be enough in the end.
    Also profile how many object-object comparisons there are for contact detection.

    the manager interface allows iteration over groups (groups
    of objects that might collide) - same object can be in multiple groups.

    This manager would probably need to contain actors, not bodies,
    to be usable to draw only visible actors, or a separate one for bodies and actors.

    Start with code using the API, then write the API itself,
    or, just write a dummy API that does no management, has just bare
    working methods and returns a group of all objects for coldetection,
    write user code both for coldetection and graphics,
    and fix the API based on results.

    The manager should contain actor, but for coarse coldetection,
    should have a mathod to return groups of bodies taken from the actors.

    Thoughts:

    narrow collision testing can better be done by
    passing through the spatialmanager (e.g. quadtree),
    and for each e.g. node, get all its pairs and detect contacts

    We could do this using delegates, i.e. the spatialmanager could have a method that
    takes a delegate that is applied on every group of nearby objects.

    alternatively: just return a reference per each array of nearby objects (content of each quadtree node)
    - without copying the array itself
17:
    GUI substitutions: parent width and height, and rewrite math expressions with these
    substitutions
17:
    Profile:
    a) VERY (~30 mins) long run with a GUIGraph, note memory usage over time, FPS,
       and, code analyst stats.
       If it turns out to be that a lot of time is spent iterating in
       GraphMonitor.Graph.data_points(), optimize it with binary search.
       If it's drawing, wait until glvideodriver overhaul.
17: 
    SpatialManager GUI monitor
17:
    Look at allocator code and try to make it more new/delete like
    by alloc, or its specific version,
    calling fake ctor, if any exists, and free calling die()
    -of course, after moving to D2, this would call the usual ctor/dtor.
    Maybe an allocator GUI monitor.
17:
    Consider writing mixin + asm based D equivalent to C xmmintrin.h
    and using that instead of direct asm in vector operations
17:
    Effect at ball-paddle collision
17:
    Rename ActorManager to SceneManager and its directory to scene/
17: 
    Effects:
    When buttons etc. working:
    when changing the gui, (e.g. moving from menu to pong, or between dialogs), 
    draw an animation with gui leaving the screen                    
    to the left. we can do this with a guioffset member in gui root

    main menu could have an ai-ai game playing in the background
18:
    cdc should have help
19:
    Use the same doc format throughout. Either Doxygen or DDoc.
    DDoc would probably be better.
    Then generate the docs, use CandyDoc or something to make them
    not look like shit.
                                                                  
    Find a way to generate DDoc for public only, or public+protected etc.
    Maybe CandyDoc can do that?

    Also add some coding examples to e.g. GUI DDoc, maybe VideoDriver
20:
    Look at other games/demos for graphics effect ideas...
    or maybe we have enough effects by now...
20:
    Resolution change in-game.
    Yeah, probably need to get all texture pages out of GPU memory and back and save other GL state.
    Only do this after end_frame, before start_frame.
    Also will need changes in Platform code.
    Better now than never (since when VBOs are done they'll need saving as well)
    Test just with a button for now, options will be added later.
    to get texture page from GPU, use glGetTexImage.
20:
    Multiple (two, and maybe option to generate) color schemes
20:
    draw_border GUI element parameter should be set in factory.
20:
    Screenshot. Probable glReadPixels from framebuffer. Also need PNG output 
24:
    Weak singleton class handling time, updating actormanager and perhaps other
    stuff. Pass this class when updating actors, instead of time_step, game_time.
    This class will also allow timed delegates,
    both delayed in real time and in game time. Use this in BallSpawner, ScoreScreen.
    Might allow timers, which, when expired, call a delegate, as well as timed signals,
    and signals that are fired at the beginning of the next frame.
    However, that might require globally accessible singletons (no testability) 
    -only do stuff that needs no singletons
20:
    Check for a newer version of (D1) Derelict, if any, just in case.
20: 
    Get rid of immediate mode:
    support VAs and maybe VBOs (not that necessary right now) -
    use VAs with colors (but support multiple vertex types)

    Line VAs/VBOs will need color per vertex.
    Texture/Font will not - we can pass it as a param to
    the shader.

    If slow, instead of Catom like caching of everything in frame to one VBO,
    first consider caching computed data (such as the VBO) for each
    draw call. (store using bucket sort based e.g. on drawing position)
    basically, if the same draw call is made in multiple frames,
    it's VBO and/or other data is computed at the first call, then stored.
    If a draw call is not made for X frames, (e.g. 8), it's deleted.
    This might be fast, but might also be very slow, we need to find out.
    Maybe it'd be good to abstract an interface for drawing lines/etc.
    within VideoDriver so we could try and switch multiple implementations.

    If we cache per frame like in Catom, we have to draw stuff out
    every time zoom/offset changes.

    Once we use custom matrices with shaders, we might simply
    store projection matrices with caches and draw all out
    at the end, but we need to learn that

    use gDebugger to profile OGL performance
24:
    Window resizing
24:
    1:
    Move FPS counter out of game code, UPS out of ActorManager. Get rid of
    statistics method/s, maybe eventcounter if can't find a use for it. 
    We can have monitor/s for that. Need to separate monitor GUI and logic.

    Ability to run monitor graphs in background w/o rendering them and then 
    render them to file (SVG or PNG).
    Even better: write out simple text, binary or gzipped file and have a 
    python or D script to render them.
    Monitors should have an 'enable' button that will make them 
    persistent, running in background even when not viewing them.
    This should be handled by a base class used by all submonitors,
    and some kind of monitor manager.
    I.e. physicsmonitor (or w/e) requests e.g. 
    MonitorManager.get_monitor("MonitorName") which will either create new monitor
    and return it or return already existing monitor.

    As for memory usage: consider more
    advanced recording and storage 
    (monitor running in background, not measuring all the time, 
     gradual data loss, gzipping in memory, dumping to file)
    Also consider making graph data time independent, supplying time
    to it through methods.

    Also manual memory management for GraphData.
    That will allow us to at least monitor its usage, and be a bit faster.
24:
    Alongside mouse_move and mouse_key, consider more advanced
    mouse_click (triggered by quick succeeding press and release),
    and mouse_drag
    these would be detected by platfom and sent to e.g GUI
25:
    Consider abstracting
    GLTexturePage to TexturePage and moving as much code as possile to VideoDriver,
    in such a way that VideoDriver, not GLVideoDriver, manages pages,
    using GLVideoDriver overriden methods. I.e. algorithms in VideoDriver,
    specific stuff in GLVideoDriver.
25:
    Advanced shaders: custom matrix, etc. passing. - see opengl superbible
    Look at Humus, Mizanin, GL forums, GL3 tutorials, etc.
    First pass matrices using loadMatrix, after it works, use
    them as shader parameters.
    also make sure to see gl3 tutorials for projection matrix
    and to tes it with various zooms/offsets
25:
    Stop printing UPS to stdout, maybe move to monitor or get rid of it altogether.
25:
    Show current time of day in the HUD
26:
    Optional(user options) smarter AI that takes note of ray hints from BallSpawner
    (only if those rays intersect with the goal - ignore if they're intersecting
     the walls to prevent extra stupidity)
14:
    Look for D files in main directory that can be put into packages.
    Maybe create the dreaded util package.
23:
    Profiling:
    Valgrind, Massif, Callgrind, Cachegrind, Sysprof, CodeAnalyst,
    manual time measurement - at least get total time and VideoDriver methods' time
    Don't forget to do this with an optimized build.
24:
    Options start: player names (also, whether the player is AI or human-
    so we can have AI/AI, AI/human, human/human)
    Character count should be limited to fit to score statictexts.
    Also time/score limit.

    Also graphics settings (enable/disable certain particle systems, maybe more)


    After that, keyboard settings for each player
25:
    Settings from ini files, also paddle, ball, wall properties
    (possibility to add more walls from INI files, but hardcoded two paddles)
    and paddle, ball graphics objects serialization (including line trail
    particle system, maybe others of coded)
    Among other things, time speed and update period of actormanager should
    be in INI files.

    GUI should also be serializable to/from INI
    There should be default set of values (in INI), e.g. for buttons in general,
    and every button could be customized with INI code that only mentions
    differences.

    FontManager settings like FontAA and FastGlyphs should be set through INI
    (also the default font?, etc.)
16:
    Draw cursor
17:
    Screen size change (in an Options dialog in menu, not during Game run)
25:
    User configurable key bindings - stored in HumanPlayer
26: 
    Sounds
17:
    Multiplayer, with single PC and over a network (test with two computers)
14:
    AI difficulty settings;
14:
    Unittests for actors, bodies etc.
    We can make actors and bodies more testable by 
    removing self-registration/self-deletion from
    body, actor ctors/die()/dtors
    Then we can test them with simple dummy manager classes,
    or, if needed, subclassed real managers with most methods as dummies

    also try to unittests subsystems, maybe using subclassed semi-dummy
    implementations - can't do this for platform/videodriver,
    others should work.

    If not possible, subsystem tests (separate app/s - tests for physicsengine, videodriver,
                     GUI, actormanager/scenemanager, actors)
    first test managers, then data managed by them
    Also look for where we can put unittests
    Still, try initializing singletons in unittest blocks first 
    (and deleting them on the end of unit tests)
    maybe create specific implementations of singletons for testing
    -based on actually used implementations.
    If needed- try to modify the code to make it more testable
    (i.e. decouple subsystems and classes they manage)
15:
    Consider tree-based math parser. Advantage is:
    GUI elements can keep the tree and just change the vaues of substitution,
    tree can be evaluated w/o being regenerated. If this is not needed, move it to 
    optimization TODOs
    This parser would use the current code to convert to postfix notation and generate
    the tree from that.
15:
    Maybe show an AI/AI game on the background of the credits screen.
    (i.e. just start the game with two AI players in credits_start
     and call pong_end from credits_end)
16:
    Ensure everything is documented in DDoc and push, for the first time
    to gitorious or github. Not necessarily announcing it.
--AFTER PONG    
4:
    Consider D2 (at this point it might be mature enough :p)
4:
    Get the thing to compile on Windows (if it doesn't work already)
    - will need windows specific high-resolution clock
4:
    Particle system overhaul. Every particle should have its own color,
    etc; and whole thing should have a better structure.
    Also, LineTrail might not need to be derived from LineEmitter
    (no need for line length, angle variation, emit velocity,
     so why is it derived?)
    and particleemitter might be merged with particlesystem

    One good idea might be to base the new particle system code
    on templates, template mixins and string mixins.
    Also look at policy based design.

    Probably, each particle should contain all the data it needs to draw
    itself and contain all drawing, updating logic.
    This way, most particle systems would only need to be template classes
    with the particle class as the template parameter.
5:
    Find some use for multithreading, e.g. asynchronous drawing
    or physics, or maybe OpenMP style (or just 2-4 threads)
    for collision detection (not penetration resolution or response,
    at least for now)
6:
    Consider mipmapping using 
    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE)
    -automatically regenerates mipmaps at SubImage calls
    - maximum mipmap level might be preferrable to not mess up very distant zooms,
    e.g. texparameter GL_TEXTURE_MAX_LEVEL (at 2, 3 or 4)
7:
    GUI substitutes:
    p_width
    p_height
    width  (width of this) - would require realign() to compute width first
    height  (height of this) - would require realign() to compute width first
8:
    timer calling a given function at expiration,
    and some kind of singleton or module to update these timers to
    check for expiration - that update would be called by whole
    pong, not game. maybe later it could be updated from separate thread, but probably
    not.
    Would be used like e.g. time.delayed_call(function(args), delay);
    
8:
    Subset of HTML tags for text drawing (just support <br> for now),
    will need a parser (fast!) and e.g. StaticText will need to use
    a class/module that will split the html text into lines.

    Alternatively, something like txt2tags or markdown. Look for
    info about both. E.g. in txt2tags two newlines in a row would
    separate paragraphs, resulting in a gap between lines.

    lightweight markup language would be good for source readability,
    html e.g. for tables (although those might work in a lml too -
    especially if we do them our own way
10:
    Test mod directories with a simple Pong "mod" that replaces shaders
    and/or fonts (say, with negative or black/white colors or something)
11:
    A debug (ini, console and/or debug GUI controlled) option to draw wireframe.
    Also might want pure white wireframe option (with a custom shader)
    Would be a good feature for GLMonitor.
12:
    Consider a hierarchical ActorManager. Physics objects would also
    need some hierarchy (or not - will see)
14:
    Could also look at the source of the Diamond memory debugger and
    use the ideas there to measure memory usage
12:
    Shaders should be an optional argument to draw_x. If no shader is passed,
    default for fonts, lines, textures is used.
    Just as images are passed to create textures, shader spec (ini) files
    should be passed to create_shader. Both images and shader spec
    files should be managed outside videodriver.
    shader spec file should contain a spec for every videodriver supported.
    GLSL shaders should be stored in whatever/shaders/glsl,
    since those will be managed on the videodriver implementation side.
    Actually, not necessarily spec per videodriver, but e.g. GLSL spec,
    fixed function spec, Cg spec etc. 
    E.g. any GLSL capable videodriver could use the GLSL spec.
13:
    resource manager, use that for font, shader, ini 
24:
    Selecting GUI elements with keyboard:
    only certain element types can be selected (e.g. button)
    (an element has a bool selectable() method):
    Arrows are used to select elements, maybe later tabs could
    select groups (would be more complicated) - if selected,
    Enter and/or some other keys could be used to control the element.
27:
    Consider moving FPSCounter to VideoDriver, Platform or somewhere else
    outside game specific code. Also need to move the code that writes
    out stats of these counters somewhere.
30?:
    Rotation (of 2D actors) - Velocity should then be in object space,
    not world space. Immediate use would be rotating balls.
    Also, the same paddle could be used up and down, just rotated.

    for 3D rotation, we might want to use a Rotation struct with opague
    implementation and stable interface so we can replace internals
    with matrices, quaternions, euler angles or whatever (of course, 2D
    rotation doesn't need this- just use a float for that)
33?:
    Might be left for later (e.g. before map editor):
    GUI: more advanced, moving/resizing (can be enabled/disabled),
    element names and getting elements by name,
    serialization (Root should have save_layout, load_layout methods),
    maybe a simple editor

    GUI could have a complex border composed of
    8 sections (top, down... + corners), using > 1.0 texcoords
    to repeat textures for resizing/support of varying sizes. 
    (once textures are done)
34:
    Drawable abstraction. 
    Can be a line mesh/mesh group, sprite (with many textures),
    3d model (with many meshes)
    Alternatively can be a single class composed of any number of 
    lines/sprites/meshes

    Serialization should go through a standardized interface so
    we can change file format (INI, XML, binary, compressed...)

    First just support lines, then add sprites, and _maybe_ add 3d
    stuff later.
35:
    Logging messages (e.g. initializing GL, etc.)- not necessarily a logging
    system yet
35:
    Screenshots (read from color buffer, but check for GL3 corecompliance)
35:
    Translatable text, and a simple string format with 
    bold/italic/underlined and text colors.
    That would be passed to the code that draws fonts.
    Might be in a single class. Should have a method to
    return the string without tags. 
    Maybe use simple CSS-like styles for the text, etc.
    Formatting should probably be left for later, but translatable text
    ASAP. Needs resource management first, though.

    We could also use shaders to invert text colors if wanted, etc.
37:
    OpenGL driver profiling:
    Might consider an Image method to_bgra() and using GL_BGRA format.
    Also profile glTexSubImage calls, consider replacing that with pbuffers
    or: combine textures to pages on cpu; when drawing, use glTexImage to
    move to GPU; when again adding textures to a page, use
    glGetTexImage to get it back to cpu side, repeat.
    Also profile all the other GL stuff, like texture drawing, shaders.
    Might consider the NVidia profiling driver for this.
    Also consider various page sizes - something like 512x512
    might have better cache performance than 4096x4096.
38: 
    Culling at videodriver level
38:
    Remapping should be done with shaders using colors with alpha 0 
    as remap colors. Only RGBA 0,0,0,0 should be a valid totally transparent color.
    R 1-255 should be used as remap index (255 remaps colors at most)
    G 0-255 (256 values) should be used as lightness of the remap color,
    and G 1-255 (255 values) as its alpha colors 
    (0 is fully transparent and should be RGBA 0,0,0,0).
39:
    Custom exception class, should add the message to the log.
39:
    Allocator should record its memory usage e.g. every second.
    This could be a good experiment for threading (make sure the other
    thread doesn't eat whole core - it must sleep if not near timer 
    expiration)

    Alternatively, we don't need threaded timer: Record memory usage
    every X allocations. Even every single allocation might work
    (we just need to add an uint to an array)
    Better, we could record memory usage and time of allocation.
    Maybe also index of type of object allocated (not the whole string)
36: 
    Console        
37:
    Platform and VideoDriver should have a static initialize(string impl_name)
    method, that will initialize the singleton with implementation
    with given name. (those names will be loaded from INI)
15:
    FormattedText class/struct that could contain various
    formatting options like line width, line spacing, 
    left/right justified/centered, in future maybe even various 
    font colors, sizes, etc.
    Would need its own viewer GUI element. (actually, just a class to break
    it up into lines  GUIStaticText and any other future text widgets could
    draw it OK)
    Maybe just use txt2tags/other lightweight markup language 
    with simple CSS or CSS-like something.
    Or a subset of HTML tags (there should be good tutorials for that and it
    would be familiar to users)

    Especially, use of <br> or some other explicit line break would be good
    instead of using \n as explicit newline.
40?:
    Particle system overhaul - turn ParticleEmitter into PointEmitter,
    add something like PolygonEmitter (or at least RectangleEmitter, LineEmitter),
    and in general, make particles more flexible.
   



Announcing:

D mailing lists
GPWiki,
GameDev.net,
OpenGameArt,
Ubuntu Forums (when packaged... or before?),
libsdl.org,
Freshmeat,
Ohloh


Packaging:

OpenSUSE Build Service?

licensing:
derelict links to sdl dynamically. so we don't need to use lgpl
we need to give credit to freetype based on its license (if used).
see freetype.org


Monitor:
1:
    Allocator monitor. Memory usage graphs (and per-type graphs?)
2:
    Measurements and graphs of how much time per frame does e.g. line drawing take,
    and display them somehow. Could measure times of non-videodriver code as well.
3:
    TexturePages info: show free/used space with slight red/blue tints,
    show borders of the texture, and borders of nodes.
    Also might be useful to have buttons to show only node borders/
    texture page/free-used
    Show whether the texture is resident, too.
4:
    FPS graph
5:
    Show stats about overhead of all textures in the driver,
    each page and its packer
6:  
    Pages: use glGetTexLevelParameteriv with some argument to get
    size the page takes up in the video memory.
7:
    PhysicsMonitor ideas:
    1:need listbox: snapshot of all collisions in a certain frame
    2:need listbox: detailed look on an object, i.e. select object and see all its parameters


Optimizations:
1:
    Allocator alloc/dealloc recording could be done using
    an associative array with typeid as index instead of a string.
    Typeid would be converted to string when writing to output.
2!:
    Right now, when the same font is loaded with different font sizes,
    it is loaded to memory twice. Share that buffer between all font
    instances with same font name to prevent duplication of memory
    (Resource manager might help here)
3!:
    Store particles in particle systems in something else than arrays,
    or use arrays with preallocated space (like C++ vectors), or use
    manual arrays. Array appending in particle systems takes 30 %
    of execution time right now.
4?:
    If particle memory usage is a problem, try to turn Timer into a template class 
    taking float, double or real to specify precision.
5?:
    Textures could be made smaller by using Vector2s for size
    instead of Vector2u. This has proven to speed up font drawing
    by ~15%. However, would probably result in a bit uglier code
    and need for asserts for too large textures/pages.)
    (would require to pass textures/glyphs by value in font drawing code)
6?: 
    Alpha testing could be used in combination with blending. I.e.
    a fragment with 0 alpha would automatically be discarded.
    This would break our remap plans, though.
    However, if we culd do this in shader (need to learn how to discard
    a fragment in shader), everything would work right.
7?:
    If color interpolation is a problem, we can create a ColorInterpolator class,
    which is basically a lookup table constructed with color a, color b, 
    and an integer specifying number of colors in the table. Any call to interpolate()
    method of that class would then return the closest table value for
    float given as ann interpolation value.
8?
    fast sqrt in math.math using a lookup table
    like, if the input is between 0-1, look it up in table #1 with 100 (float)
    results for 0.00, ... 0.99
    if 1-10, table #2 with 90 results for 1.0, ... 9.9
    etc for 100, 1000
    if more, use usual sqrtf

    alternatively: look at how opensource 3D engines do sqrt and google for other 
    methods, maybe try using carmacks' reciprocal sqrt 
    (1/sqrt, so 1/reciprocal is sqrt)
GUI:
1:
    Progress bars should be simple animation with frame depending
    of progress of something. This way we can have various fancy
    loading bars, unit construction progress C&C style, etc.
2:
    once loading GUI from files, CSS-like style code (subset),
    and look at YAGE GUI


GL1:
1:
    Remapping equivalent to shader based remapping 
    (i.e. using colors with alpha 0 as remap) can be done without shaders
    using GL_ARB_imaging with color tables, or with core OpenGL 1.x pixel
    mapping. OpenGL SuperBible explains how to use this.


Maybe:
1:
    Paddle acceleration
3:
    Graphics: Filled rectangles/circles
4:
    Consider writing a tool like 3DtoSprite seen at 
    http://irrlicht.sourceforge.net/phpBB2/viewtopic.php?t=25397
    Basically, use OpenGL to render all frames of a sprite, based on some settings
    (e.g. resolution, x,y,z model offset, camera angle, number of angles
     the object can face, ambient/directional/local lights. maybe
     even shaders used to change the colors, etc.)
    This would need 3D animations (maybe bone or frame-to-frame interpolations too),
    but it could be done with simple, brute force code as it would be
    non-realtime anyway. Try to do this through our VideoDriver
    so that any future non-OpenGL backends can be used (e.g. raytracer?)
    Note that we don't need perspective on this; ortho is OK.
    Accumulation buffer could be used for high quality AA, and per pixel lighting
    could be used as well. In future, even normals used for 3D lighting could be drawn
    (with a specific shader).
13:
    (Arkanoid) High scores - all stuff made of lines
14:
    This might not be needed if we draw stuff in the right order:
    A draw order/layer argument passed to videodriver draw method/s, 
    which should be a real value (so, in isometric games, we can 
    base it on object height) - every frame, a simple bucket sort should
    be used to sort objects to depth groups, then every group should
    be sorted using heapsort or something.
16:
    If multitextures will be supported in future, their data should
    be stored in pairs/triplets/quadruplets/etc of pages at same coords.
    All we'd need would be a special GLTexture, not Texture:
    GLTexture would contain indices of the pages.
    Might be enough to just modify GLTexture, not use a separate struct.
    A special createtexture method would be needed too.
    (taking multiple images).
17:
    If drawing text is too slow, we can cache glyph offsets for strings
    somewhere in videodriver (or a member class/struct of videodriver)
    We can search for cached strings quickly using simple bucket sort/search.
15:
    (Arkanoid)Save games (ini?)
16:
    RGBA4 (converted from RGBA8 in VideoDriver implementation) 
    -could be a switch for low-memory systems
22: 
    Try AI and/or file loading in a separate thread
