CLEAN UP, DOCUMENT, INVARIANTS/CONTRACTS AND COMMIT

CHANGE:

CONSIDER A SYSTEM SIMILAR TO OPENRA, WHERE ELEMENT POSITIONS AND SIZES
ARE DETERMINED E.G. PARENT_RIGHT - 100, WINDOW_RIGHT - 50,
ETC (!!!)

    SO E.G.: POSITION OF INFO_TEXT IN PAGESDEBUGGER CAN BE PARENT_RIGHT - 74, 2
    AND SIZE CAN BE 72, 256 !!!


    FOR NOW, WE DON'T EVEN NEED COMPLICATED EQUATIONS LIKE OPENRA, JUST OFFSETS
    RELATIVE TO PARENT OR WINDOW(GUI ROOT) MIN/MAX COORDS,
    BUT LATER, IT WOULD BE USEFUL TO PARSE STRINGS WITH SUBSTITUTIONS LIKE OPENRA DOES.
    FIRST, JUST USE THESE OFFSETS, THOUGH.

    ACTUALLY, WE MIGHT NEED PARSING SUPPORT FROM THE START AS THE FIRST EXAMPLE
    (PARENT_RIGHT - 74, 2) NEEDS TO OFFSET MAX FOR X, MIN FOR Y.

    SO, IMPLEMENT A SIMPLE EQUATION PARSER WITH ONLY SUBSTITUTION, ADDITION AND 
    SUBTRACTION FOR NOW.

    ELEMENTS WILL NEED STRING MEMBERS FOR HEIGHT, WIDTH, POS_X AND POS_Y
    AND ACTUAL BOUNDS WILL BE BASED ON THESE (CALCULATED IN REALIGN).


    GOOGLE EQUATION PARSING- MAYBE USE A GENERATOR, OR, 
    FIRST REMOVE SPACES, THEN SUBSTITUTE MACROS, THEN CONVERT TO POSTFIX,
    THEN COMPUTE


    AFTER ALL THAT IS DONE, WE'LL ONLY NEED TABCONTROL TO SIMPLIFY DEBUGGER CODE
    (AND GET RID OF SUBDEBUGGER)


    ALSO, STILL CONSIDER REMOVING MOST (ALL?) ARGS FROM ELEMENT'S CTORS
    AND SETTING STUFF THROUGH ACCESSORS (ESP. POSITION, SIZE)
    BUT FOR NOW (ONCE WE HAVE THE PARSER WORKING) WE CAN TEMPORARILY HAVE
    TWO CONSTRUCTORS UNTIL WE MOVE THE CODE OVER 

    ALSO, WE NEED THE UPDATE() METHOD FOR GUI ELEMENTS, CALLED BEFORE FRAME STARTS

    ALSO: RENAME DEBUGGER TO MONITOR

    Also abstract debugger font, button sizes

    ANYWAY: PARSER FIRST (AFTER CLEANING UP)







































In the end, think about refactoring parts of debugger code to a 
GUI element (tabwindow or something - an element with buttons-tabs that specify
which subdebugger is displayed

along the way, we might want to get rid of the SubDebugger class -it's
useless now.

The tabwindow will need a verticalpacker, horizontalpacker,
just like QT- code this and it might end up being adequate
for positioning all game GUI code.

Tabview or tabcontrol might be a better name for tabwindow

NOTE: WE MUST KEEP IN MIND THAT WE NEED TO SUPPORT RA2-LIKE GUI
WITH FULLY TEXTURED, NON-RESIZABLE ELEMENTS!
WHICH MEANS IT MIGHT BE A GOOD IDEA TO GIVE UP ON THESE IDEAS (AT LEAST FOR NOW)

ACTUALLY, LET'S CONTINUE - WE CAN SIMPLY DISABLE STRETCHING ON ELEMENTS THAT CAN'T 
BE STRETCHED- THAT WAY E.G. PAGE VIEW OR MENU WILL BE STRETCHED, BUT NOT
INDIVIDUAL BUTTONS, CAMEOS, IMAGE ELEMENTS IN MENU, ETC.
START WITH UNSTRETCHABLE TAB BUTTONS TO TEST HOW THIS WORKS
(ACTUALLY, TABCONTROL CLASS WILL HANDLE THAT)


Partially-obsolete:
    packers might make ctors with positions obsolete, so maybe move 
    positions from GUIElement and derived classes' ctors to an accessor.
    (as they'll only be needed when no packer is used)
    Packers would still be optional, though, e.g. current main menu doesn't really need
    them
    Also, maybe within packers, we could have horizontal/vertical 
    (depending on packer type) aligns- elements with left will be placed left,
    those with right will be placed right, anything in between will be stretched?

Instead:
    Use QT style layouts not GUI elements, derived from a Layout class.
    Layouts can be added to GUI elements using GUIElement.layout(Layout layout)
    Layout set then manages the element's widgets.
    So e.g. for PagesDebugger(can call it PagesView, too),
    we set XBoxLayout (equivalent to HBoxLayout), and that will handle
    the two elements inside (view and info text) based on spacing set, 
    their base sizes (?) and stretch factors (read on that) - 
    that will need a SizePolicy enum or class too.

    Also, we need spacers for layouts (at least horizontal/vertical ones-
    not necessarily for grid if ever impemented)

    Maybe we should also be able to add sublayouts to layouts,
    i.e. not only layout->add_element() but also layout->add_layout()
    similarly, we should have add_spacer() (would just add an int)

    also, stretch  factors should be set with layout->add_element,
    not members of elements.

    However, MinimumSize and SizePolicy need to be element specific
    (we don't need Size (as in not minimum) for now) - minimum size
    is the size we have by default, e.g. the 320xwhatever debugger, 
    and real size will depend on stretching.
    MinimumSize will probably be set in ctor.

We might also want not to connect widgets to parents at construction.
Widgets might also be connected through layouts so we can add leyout specific arguments.

Temporarily, we might need two constructors for elements so we can change GUI subsystem
withough immendiately breaking all the existing code.


Anyway, read a bit on QT/Tk/Hybrid/Agar/whatever first

First test tabwindow on gldebugger (which already has more than one tab),
then main debugger.

Also refactor debugger font size from everywhere around the place to 
a single int (global function in debugger maybe?)
or better- one font size per debugger, e.g. gldebugger has its font
size, global debugger has its own, etc.
Same with button sizes and maybe with their positions

GUI elements might also need an update() method, 
update frame length, etc., like actormanager - with updates happening less
frequently (15UPS?)
GUIRoot update() could call draw(), just like ActorManager.
However, it'd be better to keep them separate, so e.g. debugger can
get videodriver data before the frame has started.
Also, gldebugger subdebuggers' update timers could be checked at this update.
Especially as they must be update outside the draw phase to show correct values.


START ESSENTIAL -------------------------------
14:
    Make it impossible to add a child that already is a child to a GUI element.
    (i.e. to add a child twice) - caused a bug recently - use an assert to do this
14:
    Valgrind, Massif.
    Look (google, etc.) for ways to measure memory in detail.
14:
    Complete overhaul of memory usage everywhere 
    (with classes as well, e.g. maybe actors should truly be removed)

    In D2, might even attempt a delete!(T)() function for classes
    that'd call clear and gc.free()

    Could also look at the source of the Diamond memory debugger and
    use the ideas there to measure memory usage
15:
    Move away from DSSS, (include derelict)
    also, get the newest derelict
    Debug, release, doc targets

    Consider xfBuild, since it's not dead  
    Maybe even basic makefile.
    Also, create a code::blocks project.


END ESSENTIAL -------------------------------

13: 
    Credits button and text 
    (maybe a simple demo showing random balls or an AI-AI game in background)
14:
    Look for files in main directory that can be put into packages.
14:
    Display score with text(orbitron?)
    Make game area a bit narrower and taller
14:
    Intro screen

    Some kind of start game animation and a possibility to end game
    and start anew

    Also will need a victory condition that ends game as well
    as allow the player to end the game (in both cases, returning
    to intro screen/menu)

    Games should be limited by first to reach score or by time limit.
    Maybe both. (and overtime?) - that might require font work, though
14:
    Graphics effect: either some kind of motion blur effect for the paddle,
    or some kind of pulsating lines inside the paddle.
15:
    Graphics effect:
    Add a lot of almost invisible fast moving balls, or just trails, that bounce normally,
    but don't matter in game score. Generate them randomly (from center? 
    from a random point on center horizontal line? or, from 
    a point that is moving around but always within screen)
    Alternatively a few short-trail balls that can bounce off of each others'
    trails

    another alternative would be some other subtle background effect.
16:
    Graphics effect:
    Particle systems at destruction of paddles, balls (e.g. at the end of game 
    or when player loses a life) 
    Effects both for normal (ESC) exit and victory/defeat exit
    also an effect on start of game, and a countdown until the
    ball is thrown
16:
    Have a countdown before each ball spawn. Should also
    display the rough area where it might go (~ 90 deg)
17:
    Look at LBreakout2, other pong/arkanoid games, especially how they handle physics.
    Maybe then implement ball reflection based on paddle movement.
17: 
    Effects:
    When buttons etc. working:
    when changing the gui, (e.g. moving from menu to pong, or between dialogs), 
    draw an animation with gui leaving the screen
    to the left. we can do this with a guioffset member in gui root

    main menu could have an ai-ai game playing in the background
18:
    Maybe try to even remove .get from singletons (hybrid has done it somehow)
19:
    Use the same doc format throughout. Either Doxygen or DDoc.
    DDoc would probably be better.
20:
    Look at other games/demos for graphics effect ideas
20: 
    Get rid of immediate mode:
    support VAs and maybe VBOs (not that necessary right now) -
    use VAs with colors (but support multiple vertex types)

    Line VAs/VBOs will need color per vertex.
    Texture/Font will not - we can pass it as a param to
    the shader.

    If we cache per frame like in Catom, we have to draw stuff out
    every time zoom/offset changes.

    Once we use custom matrices with shaders, we might simply
    store projection matrices with caches and draw all out
    at the end, but we need to learn that
25:
    Advanced shaders: custom matrix, etc. passing. - see opengl superbible
    Look at Humus, Mizanin, GL forums, GL3 tutorials, etc.
    First pass matrices using loadMatrix, after it works, use
    them as shader parameters.
    also make sure to see gl3 tutorials for projection matrix
    and to tes it with various zooms/offsets
23:
    Collision optimization: ignore too distant actors/lines/whatever
    early.
22:
    Both graphics data and physics data should have their
    own classes (or completely abstract interfaces) - contained in Actor.
    Actors should collide in update_physics() by passing Actors just like 
    until now, not by passing PhysicsObjects
22:
    Improved collision code to prevent/minimize tunneling
23:
    Do some basic profiling: KCacheGrind (No OpenGL perspective),
    OProfile (better?), gettime - at least get total time and VideoDriver 
    methods' time
    Don't forget to do this with an optimized build.
    Also check with valgrind for memory leaks (if any).
    Also add precision time-based measurement code like in MiniINI
    to determine e.g. exact time spent with GL calls,
    exact time spent in VideoDriver outside GL and maybe more.

    Profile both debug and optimized.

    Notable stuff to profile:
    use of arrays in particle systems. Maybe create a global particle pool
    or something.

    Drawing of huge texts

    If memory is a problem, maybe try to turn Timer into a template class 
    taking float, double or real to specify precision.

    Textures could be made smaller by using Vector2s for size
    instead of Vector2u. This has proven to speed up font drawing
    by ~15%. However, would probably result in a bit uglier code
    and need for asserts for too large textures/pages.)
    (would require to pass textures/glyphs by value in font drawing code)
25:
    Settings from ini files, also paddle, ball, wall properties
    (possibility to add more walls from INI files, but hardcoded two paddles)
    and paddle, ball graphics objects serialization (including line trail
    particle system, maybe others of coded)
    Among other things, time speed and update period of actormanager should
    be in INI files.

    GUI should also be serializable to/from INI
    There should be default set of values (in INI), e.g. for buttons in general,
    and every button could be customized with INI code that only mentions
    differences.

    FontManager settings like FontAA and FastGlyphs should be set through INI
    (also the default font?, etc.)
16:
    Draw cursor
17:
    Screen size change (in an Options dialog in menu, not during Game run)
25:
    User configurable key bindings - stored in HumanPlayer
26: 
    Sounds
17:
    Multiplayer, with single PC and over a network (test with two computers)
14:
    AI difficulty settings;

--AFTER PONG    
8:
    Subset of HTML tags for text drawing (just support <br> for now),
    will need a parser (fast!) and e.g. StaticText will need to use
    a class/module that will split the html text into lines.

    Alternatively, something like txt2tags or markdown. Look for
    info about both. E.g. in txt2tags two newlines in a row would
    separate paragraphs, resulting in a gap between lines.

    lightweight markup language would be good for source readability,
    html e.g. for tables (although those might work in a lml too -
    especially if we do them our own way
9:
    GUI elements for vertical and horizontal arranging of items,
    use them in debuggers, and refactor debugger GUI code.
    Maybe even a tab bar + tab element? 
    (since debuggers are basically sets of tabs with buttons)
    
    maybe, but probably not :
    GUI should support a simple box model similar to HTML/CSS,
    with margin, padding, absolute, relative to parent, relative to previous
    child positioning,
    and vertical/horizontal aligning.

10:
    Test mod directories with a simple Pong "mod" that replaces shaders
    and/or fonts (say, with negative or black/white colors or something)
11:
    A debug (ini, console and/or debug GUI controlled) option to draw wireframe.
    Also might want pure white wireframe option (with a custom shader)
12:
    Shaders should be an optional argument to draw_x. If no shader is passed,
    default for fonts, lines, textures is used.
    Just as images are passed to create textures, shader spec (ini) files
    should be passed to create_shader. Both images and shader spec
    files should be managed outside videodriver.
    shader spec file should contain a spec for every videodriver supported.
    GLSL shaders should be stored in whatever/shaders/glsl,
    since those will be managed on the videodriver implementation side.
    Actually, not necessarily spec per videodriver, but e.g. GLSL spec,
    fixed function spec, Cg spec etc. 
    E.g. any GLSL capable videodriver could use the GLSL spec.
13:
    resource manager, use that for font, shader, ini 
24:
    Selecting GUI elements with keyboard:
    only certain element types can be selected (e.g. button)
    (an element has a bool selectable() method):
    Arrows are used to select elements, maybe later tabs could
    select groups (would be more complicated) - if selected,
    Enter and/or some other keys could be used to control the element.
27:
    Consider moving FPSCounter to VideoDriver, Platform or somewhere else
    outside game specific code. Also need to move the code that writes
    out stats of these counters somewhere.
30?:
    Rotation (of 2D actors) - Velocity should then be in object space,
    not world space. Immediate use would be rotating balls.
    Also, the same paddle could be used up and down, just rotated.

    for 3D rotation, we might want to use a Rotation struct with opague
    implementation and stable interface so we can replace internals
    with matrices, quaternions, euler angles or whatever (of course, 2D
    rotation doesn't need this- just use a float for that)
33?:
    Might be left for later (e.g. before map editor):
    GUI: more advanced, moving/resizing (can be enabled/disabled),
    element names and getting elements by name,
    serialization (Root should have save_layout, load_layout methods),
    maybe a simple editor

    GUI could have a complex border composed of
    8 sections (top, down... + corners), using > 1.0 texcoords
    to repeat textures for resizing/support of varying sizes. 
    (once textures are done)
34:
    Drawable abstraction. 
    Can be a line mesh/mesh group, sprite (with many textures),
    3d model (with many meshes)
    Alternatively can be a single class composed of any number of 
    lines/sprites/meshes

    Serialization should go through a standardized interface so
    we can change file format (INI, XML, binary, compressed...)

    First just support lines, then add sprites, and _maybe_ add 3d
    stuff later.
35:
    Logging messages (e.g. initializing GL, etc.)- not necessarily a logging
    system yet
35:
    Translatable text, and a simple string format with 
    bold/italic/underlined and text colors.
    That would be passed to the code that draws fonts.
    Might be in a single class. Should have a method to
    return the string without tags. 
    Maybe use simple CSS-like styles for the text, etc.
    Formatting should probably be left for later, but translatable text
    ASAP. Needs resource management first, though.

    We could also use shaders to invert text colors if wanted, etc.
37:
    OpenGL driver profiling:
    Might consider an Image method to_bgra() and using GL_BGRA format.
    Also profile glTexSubImage calls, consider replacing that with pbuffers
    or: combine textures to pages on cpu; when drawing, use glTexImage to
    move to GPU; when again adding textures to a page, use
    glGetTexImage to get it back to cpu side, repeat.
    Also profile all the other GL stuff, like texture drawing, shaders.
    Might consider the NVidia profiling driver for this.
    Also consider various page sizes - something like 512x512
    might have better cache performance than 4096x4096.
38: 
    Culling at videodriver level
39:
    Custom exception class, should add the message to the log.
39:
    Allocator should record its memory usage e.g. every second.
    This could be a good experiment for threading (make sure the other
    thread doesn't eat whole core - it must sleep if not near timer 
    expiration)

    Alternatively, we don't need threaded timer: Record memory usage
    every X allocations. Even every single allocation might work
    (we just need to add an uint to an array)
    Better, we could record memory usage and time of allocation.
    Maybe also index of type of object allocated (not the whole string)
36: 
    Console        
37:
    Platform and VideoDriver should have a static initialize(string impl_name)
    method, that will initialize the singleton with implementation
    with given name. (those names will be loaded from INI)
15:
    FormattedText class/struct that could contain various
    formatting options like line width, line spacing, 
    left/right justified/centered, in future maybe even various 
    font colors, sizes, etc.
    Would need its own viewer GUI element. (actually, just a class to break
    it up into lines  GUIStaticText and any other future text widgets could
    draw it OK)
    Maybe just use txt2tags/other lightweight markup language 
    with simple CSS or CSS-like something.
    Or a subset of HTML tags (there should be good tutorials for that and it
    would be familiar to users)

    Especially, use of <br> or some other explicit line break would be good
    instead of using \n as explicit newline.
39:
    Consider D2 (at this point it might be mature enough :p)



Announcing:

D mailing lists
GPWiki,
GameDev.net,
OpenGameArt,
Ubuntu Forums (when packaged... or before?),
libsdl.org,
Freshmeat,
Ohloh


Packaging:

OpenSUSE Build Service?

licensing:
derelict links to sdl dynamically. so we don't need to use lgpl
we need to give credit to freetype based on its license (if used).
see freetype.org


Debugger:
1:
    Allocator debugger. Maybe memory usage graphs (and per-type graphs?)
    Would need a graph GUI element.
2:
    Measurements of how much time per frame does e.g. line drawing take,
    and display them somehow. Could measure times of non-videodriver code as well.
3:
    TexturePages info: show free/used space with slight red/blue tints,
    show borders of the texture, and borders of nodes.
    Also might be useful to have buttons to show only node borders/
    texture page/free-used
4:
    Graphs showing how various debugger data changes over time
    FPS would be also good to show, and in graph as well
5:
    Show stats about overhead of all textures in the driver,
    each page and its packer

Optimizations:
1:
    Allocator alloc/dealloc recording could be done using
    an associative array with typeid as index instead of a string.
    Typeid would be converted to string when writing to output.

GUI:
1:
    Progress bars should be simple animation with frame depending
    of progress of something. This way we can have various fancy
    loading bars, unit construction progress C&C style, etc.


Maybe:
1:
    Paddle acceleration
2: 
    NOTE: needed if we can set position of actors
    We need to assert that an actor's position is not being changed
    (through its position() API function) between its update_physics()
    and update() calls. Maybe use a bool data member only used in
    debug builds.
3:
    Graphics: Filled rectangles/circles
13:
    (Arkanoid) High scores - all stuff made of lines
14:
    This might not be needed if we draw stuff in the right order:
    A draw order/layer argument passed to videodriver draw method/s, 
    which should be a real value (so, in isometric games, we can 
    base it on object height) - every frame, a simple bucket sort should
    be used to sort objects to depth groups, then every group should
    be sorted using heapsort or something.
16:
    If multitextures will be supported in future, their data should
    be stored in pairs/triplets/quadruplets/etc of pages at same coords.
    All we'd need would be a special GLTexture, not Texture:
    GLTexture would contain indices of the pages.
    Might be enough to just modify GLTexture, not use a separate struct.
    A special createtexture method would be needed too.
    (taking multiple images).
17:
    If drawing text is too slow, we can cache glyph offsets for strings
    somewhere in videodriver (or a member class/struct of videodriver)
    We can search for cached strings quickly using simple bucket sort/search.
15:
    (Arkanoid)Save games (ini?)
16:
    RGBA4 (converted from RGBA8 in VideoDriver implementation) 
    -could be a switch for low-memory systems
22: 
    Try AI and/or file loading in a separate thread
